# 操作系统

## 1. 计算机系统

### 1.1 组成：

硬件子系统和软件子系统

![](D:\项目\markdown\操作系统\计算机系统用户视图.png)



### 1.2 硬件子系统

#### 1.2.1 CPU 

**//最核心的部件**

运算核心和控制核心

包括：

​	运算逻辑部件：一个或多个运算器

​	寄存器部件：包括通用寄存器、控制与状态寄存器，以及高速缓冲存储器（cache）

​	控制部件：实现各部件间联系的数据、控制及状态的内部总线；负责对指令译码、发出为完成每条指令所要执行操作的控制信号、实现数据传输等功能的部件

##### 微处理器

目前几乎所有计算机的CPU使用的都是微处理器

除了作用CPU的通用微处理器之外，还有许多专用的微处理器产品：绘图处理器、通信处理器等

用于执行系统软件和应用软件的微处理器称为CPU



#### 1.2.2 主存储器

![](D:\项目\markdown\操作系统\存储器的组织层次.png)



#### 1.2.3 外围设备

​	输出设备

​	输入设备

​	存储设备

​	机机通信设备

**设备控制方式**：

​	轮询方式：CPU忙式控制，CPU执行内存数据交换

​	中断方式：CPU启动外设，外设中断CPU，CPU执行内存数据交换

​	DMA方式：



#### 1.2.4 总线

计算机各种功能部件之间传送信息的公共通信干线，是CPU、内存、输入输出设备传递信息的共用通道

计算机的各个部件通过总线相连接，外围设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统

##### 分类

**按照所传输的信息种类**

​	总线包括一组控制线、一组数据线和一组地址线

**内部总线**：用于CPU芯片内部连接各元件

**系统总线**：用于连接CPU、存储器和各种I/O模块等主要部件

**通信总线**：用于计算机系统间的通信



### 1.3 计算机软件系统的组成

系统软件：操作系统、实用程序、语言处理程序、数据库管理系统

​	操作系统实施对各种软硬件资源的管理控制

​	实用程序为方便用户所设，如文本编辑等

​	语言处理程序把用汇编语言/高级语言编写的程序，翻译成可执行的机器语言程序

支撑软件：有接口软件、工具软件、环境数据库，支持用户使用计算机的环境，提供开发工具

应用软件：用户按需求自行编写的专用程序

![](D:\项目\markdown\操作系统\计算机程序执行过程.png)



### 1.4 操作系统

最基础的系统软件，管理软硬件资源、控制程序执行，改善人机界面，合理组织计算机工作流程，为用户使用计算机提供良好运行环境

#### 1.4.1 组成

进程调度子系统

进程通信子系统

内存管理子系统

设备管理子系统

文件管理子系统

网络通信子系统

作业控制子系统

#### 1.4.2 类型

**从操作控制方式看**

​	多道批处理操作系统，采用脱机控制方式

​	分时操作系统，采用交互控制方式

​	实时操作系统

​	

### 1.5 资源

处理器资源：哪个程序占有处理器运行

内存资源：程序/数据在内存中如何分布？

设备管理：如何分配、去配和使用设备

信息资源管理：如何访问文件信息？

信号量资源：如何管理进程之间的通信？



#### 1.5.1 驱动程序

最底层的、直接控制和监视各类硬件资源的部分

隐藏底层硬件的具体细节，并向其他部分提供一个抽象的、通用的接口



#### 1.5.2 共享与分配方式

##### 共享：

​	独占使用

​	并发使用

##### 分配：

​	静态分配

​	动态分配：谁用谁分配

​	资源抢占：优先级高用



### 1.6 程序控制

![](D:\项目\markdown\操作系统\单道程序控制.png)

![](D:\项目\markdown\操作系统\多道程序控制.png)	

#### 多道程序设计：

​	让多个程序同时进入计算机的主存储器进行计算

##### 多道程序设计的特点：

​	CPU与外部设备充分并行

​	外部设备之间充分并行

​	发挥CPU的使用效率

##### 实现：

​	为进入内存执行的程序建立管理实体：进程

​	OS应能管理与控制进程程序的执行

​	OS协调管理各类资源在进程间的使用

##### 实现要点：

​	如何使用资源：调用操作系统提供的服务例程

​	如何复用CPU：调度程序（在CPU空闲时让其他程序运行）

​	如何使CPU与I/O设备充分并行：设备控制器与通道（专用的I/O处理器）

​	如何让正在运行的程序让出CPU：中断（中断正在执行的程序，引入OS处理）	



### 1.7 控制计算

OS规定了合理操作计算机的工作流程

OS的操作接口——系统程序OS提供给用户的功能级接口，为用户提供的解决操作计算机和计算共性问题的所有服务的集合

#### OS的两类作业级接口：

##### 脱机作业控制方式：

​	![](D:\项目\markdown\操作系统\脱机作业控制方式.png)

##### 联机作业控制方式

![](D:\项目\markdown\操作系统\联机作业控制方式.png)



#### 命令解释程序：

接受和执行一条用户提出的对作业的加工处理命令

![](D:\项目\markdown\操作系统\命令解释程序.png)

##### 处理过程

![](D:\项目\markdown\操作系统\命令解释程序处理过程.png)



### 1.8 人机交互

![](D:\项目\markdown\操作系统\操作系统人机交互.png)

##### 交互控制方式

​	行命令控制方式

​	全屏幕控制方式

斯坦福研究所提出的发展计划：

​	代表性成果：鼠标、菜单与窗口控制



##### WIMP界面

![](D:\项目\markdown\操作系统\WIMP界面.png)



##### 多媒体计算机

![](D:\项目\markdown\操作系统\多媒体计算机.png)



##### 虚拟现实系统

![](D:\项目\markdown\操作系统\虚拟现实系统.png)



### 1.9 程序接口

操作系统的程序接口——系统调用

操作系统实现的完成某种特定功能的过程；为所有运行程序提供访问操作系统的接口



##### 实现机制

陷入处理机制：计算机系统中控制和实现系统调用的机制

陷入指令：也称访管指令，或异常中断指令，计算机系统为实现系统调用而引起处理器中断的指令

每个系统调用都事先规定了编号，并在约定寄存器中规定了传递给内部处理程序的参数



##### 实现要点

编写系统调用处理程序

设计一张系统调用入口地址表，每个入口地址指向一个系统调用的处理程序，并包含系统调用自带参数的个数

陷入处理机制需开辟现场保护区，以保存发生系统调用时的处理器现场



##### 实现流程

![](D:\项目\markdown\操作系统\系统调用实现流程.png)



### 1.10 系统结构

结构设计是关键

#### OS构件

内核、进程、线程、管程

#### 设计概念

模块化、层次式、虚拟化





#### 内核

内核设计是OS设计中最为复杂的部分

![](D:\项目\markdown\操作系统\操作系统内核.png)

![](D:\项目\markdown\操作系统\操作系统内核2.png)



#### 层次结构

![](D:\项目\markdown\操作系统\层次结构.png)

![](D:\项目\markdown\操作系统\层次结构2.png)





## 2. 处理器

### 2.1 处理器与寄存器

#### 处理器

![](D:\项目\markdown\操作系统\处理器部件简单示意.png)



#### 寄存器

##### 用户程序可见寄存器

可以使程序员减少访问主存储器的次数，提高指令执行的效率

所有程序可使用，包括应用程序和系统程序

​	数据寄存器：又称通用寄存器

​	地址寄存器：索引、栈指针、段地址等寄存器



##### 控制与状态寄存器

用于控制处理器的操作；主要被具有特权的操作系统程序使用，以控制程序的执行。

程序计数器PC：存储将取指令的地址

指令寄存器IR：存储最近使用的指令

条件码CC： CPU为指令操作结果设置的位，标志正/负/零/溢出等结果

标志位：中断位、中断允许位、中断屏蔽位、处理器模式位、内存保护位等等



##### 程序状态字PSW

指记录当前程序运行的动态信息，通常包含：

​	程序计数器，指令寄存器，条件码

​	中断字，中断允许/禁止，中断屏蔽，处理器模式，内存保护、调试控制

也是计算机系统的寄存器

​	通常设置一组控制与状态寄存器



### 2.2 指令

#### 机器指令

计算机系统执行的基本命令，是中央处理器执行的基本单位

指令由一个或多个字节组成，包括操作码字段、一个或多个操作数地址字段、以及一些表征机器状态的状态字以及特征码

指令完成各种算数逻辑运算、数据传输、控制流跳转征码



#### 执行过程

![](D:\项目\markdown\操作系统\指令执行过程.png)



#### 执行周期与流水线

![](D:\项目\markdown\操作系统\指令执行周期与流水线.png)



#### 特权指令与非特权指令

用户程序并非能够使用全部机器指令，那些与计算机核心资源相关的特殊指令会被保护

如：启动I/O指令、置PC指令、等等

核心资源相关的指令只能被操作系统程序使用

特权指令：只能被操作系统内核使用的指令

非特权指令：能够被所有程序使用的指令

##### 处理器模式

![](D:\项目\markdown\操作系统\处理器模式.png)

##### 模式切换

用户模式和内核模式的互相转换



###### 用户->内核

程序运行时发生中断并响应（外围设备的中断）

程序运行时发生异常（缺页异常）

程序请求操作系统服务（系统调用）



###### 内核->用户

OS内核处理完成后，调用中断返回指令（如Intel的iret）触发



### 2.3 中断

#### 广义的中断

指程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程

操作系统是中断驱动的；中断是激活操作系统的唯一方式

#### 狭义的中断

来源于处理器之外的中断事件，即与当前运行指令无关的中断事件，如I/O中断、时钟中断、外部信号中断等

#### 异常

当前运行指令引起的中断事件，如地址异常、算术异常、处理器硬件故障等

#### 系统异常

执行陷入指令而触发系统调用引起的中断事件，如请求设备、请求I/O、创建进程等



### 2.4 中断源

##### 处理器硬件故障中断事件

由处理器、内存储器、总线等硬件故障

处理原则为：保护现场，停止设备，停止CPU，向操作员报告，等待人工干预



##### 程序性中断事件

处理器执行机器指令引起

​	除数为零、操作数溢出等算数异常：简单处理，报告用户；也可以由用户编写中断元源程序处理

​	非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程

​	终止进程指令：终止进程

​	虚拟地址异常：调整内存后重新执行指令



##### 自愿性中断事件

处理器执行陷入指令请求OS服务引起；在操作系统中，它一般又被称作系统调用

请求分配外设、请求I/O等、等等

处理流程是：陷入OS，保护现场，根据功能号查入口地址，跳转具体处理程序



##### I/O中断事件

来源于外围设备报告I/O状态的中断事件

​	I/O完成：调整进程状态，释放等待进程

​	I/O出错：等待人工干预

​	I/O异常：等待人工干预



##### 外部中断事件

有外围设备发出的信号引起的中断事件

​	时钟中断、间隔时钟中断：记时与时间片处理

​	设备报道与结束中断：调整设备表

​	键盘/鼠标信号中断：根据信号做出相应反应

​	关机/重启动中断：写回文件，停止设备与CPU



### 2.5 中断系统

计算机系统中响应和处理中断的系统，包括硬件子系统和软件子系统两部分

中断响应应由硬件子系统完成

中断处理由软件子系统完成



#### 2.5.1 中断响应处理与指令执行周期

![](D:\项目\markdown\操作系统\中断响应处理与指令执行周期.png)



#### 2.5.2 中断装置

计算机系统中发现并响应中断/异常的硬件装置称为中断装置

由于中断源的多样性，硬件实现的中断装置有多种，分别处理不同类型的中断

##### 分类

处理器外的中断：由中断控制器发现和响应

处理器内的异常：由指令的控制逻辑和实现线路发现和响应，响应机制称为陷阱

请求OS服务的系统异常：处理器执行陷入指令时直接触发，响应机制称为系统陷阱



#### 2.5.3 中断控制器

CPU中的一个控制部件，包括中断控制逻辑线路和中断寄存器

​	外部设备向其发出中断请求IRQ，在中断寄存器中设置已发生的中断

​	指令处理结束前，会检查中断寄存器，若有不被屏蔽的中断产生，则改变处理器内操作的顺序，引出操作系统中的中断处理程序



#### 2.5.4 陷阱与系统陷阱

指令的逻辑实现线路的一部分

​	执行指令出现异常后，会根据异常情况转向操作系统的异常处理程序

​	出现虚拟地址异常后，需要重新执行指令，往往越过陷阱独立设置页面异常处理程序

​	执行陷入指令后，越过陷阱处理，触发系统陷阱，激活系统调用处理程序



#### 2.5.5 中断响应过程

**发现中断源，提出中断请求**

​	发现中断寄存器中记录的中断

​	决定这些中断是否被屏蔽

​	当有多个要响应的中断源时，根据规定的优先级选择一个

**中断当前程序的执行**

​	保存当前程序的PSW/PC到核心栈

**转向操作系统的中断处理程序**



#### 2.5.6 中断处理

##### 中断处理程序

操作系统处理中断事件的控制程序，主要任务是处理中断事件和恢复正常操作

​	保护未被硬件保护的处理器状态

​	通过分析被中断进程的PSW中断码字段，识别中断源

​	分别处理发生的中断事件

###### 	恢复正常操作

​		情况一：对于某些中断，在处理完毕后，直接返回刚刚被中断的进程

​		情况二：对于其他一些中断，要中断当前进程的运行，调整进程队列，启动进程调度，选择下一个执行的进程并恢复其执行

##### 中断处理流程

![](D:\项目\markdown\操作系统\中断系统处理流程.png)



#### 2.5.7 多中断的响应与处理

##### 中断屏蔽

当计算机检测到中断时，中断装置通过中断屏蔽位决定是否响应已发生的中断

有选择的响应中断



##### 中断优先级

当计算机同时检测到多个中断时，中断装置响应中断的顺序

有优先度的响应中断

一种可能的处理次序：

​	![](D:\项目\markdown\操作系统\一种可能的处理顺序.png)

不同类型的操作系统有不同的顺序



##### 中断的嵌套处理

当计算机响应中断后，在中断处理过程中，可以再响应其他中断

操作系统是性能攸关的程序，且中断响应处理有硬件要求，考虑系统效率和实现代价问题，中断的嵌套处理应限制在一定层数内，如3层

中断的嵌套处理改变终端处理次序，先响应的有可能后处理



##### 决定终端处理次序的因素

中断屏蔽可以使中断装置不响应某些中断

中断优先级决定了中断装置响应中断的次序

中断可以嵌套处理，但嵌套的层数应有限制

中断的嵌套处理改变了中断处理的次序



![](D:\项目\markdown\操作系统\顺序中断处理.png)

![](D:\项目\markdown\操作系统\嵌套中断处理.png)



### 2.6 进程

OS为正在运行程序建立一个管理实体——进程

进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动

进程是OS进行资源分配和调度的一个独立单位



#### 五个实体

（OS管理运行程序的）数据结构P

（运行程序的）内存代码C

（运行程序的）内存数据D

（运行程序的）通用寄存器信息R

（OS控制程序执行的）程序状态字信息PSW



#### 举例

不同程序在不同数据集上运行：构成两个无关进程

![](D:\项目\markdown\操作系统\进程举例1.png)



不同程序在相同数据集上运行：构成两个共享数据的交往进程

![](D:\项目\markdown\操作系统\进程举例2.png)





相同代码在不同数据集上运行：构成两个共享代码的无关进程（共享的代码称为可在如程序，如编辑器；可再入程序是纯代码的）

![](D:\项目\markdown\操作系统\进程举例3.png)



![](D:\项目\markdown\操作系统\进程举例4.png)



#### 2.6.1 进程状态

**运行态**

​	指进程占有处理器运行

**就绪态**

​	指进程具备运行条件等待处理器运行

**阻塞态**

​	指进程由于等待资源、输入输出、信号等而不具备运行条件



##### 状态转换

![](D:\项目\markdown\操作系统\进程状态转换.jpg)

运行->阻塞

​	等待资源、I/O、信号

阻塞->就绪

​	资源满足、I/O结束、信号完成

就绪->运行

​	处理器空闲时选择更高优先权进程抢占

运行->就绪：

​	运行时间片到、有更高优先权的进程



#### 2.6.2 进程挂起

![](D:\项目\markdown\操作系统\进程挂起.png)



##### 挂起的选择与恢复

![](D:\项目\markdown\操作系统\进程挂起的选择与恢复.png)



#### 2.6.3 进程的数据描述

##### 进程控制块

Process Control Block

PCB是OS用于记录和刻画进程状态及环境信息的数据结构

借助PCB，OS可以全面管理进程的物理实体，刻画进程的执行现状，控制进程的执行

![](D:\项目\markdown\操作系统\进程控制块.png)

###### 标识信息

用于存放唯一标识该进程的信息

​	系统分配的标识号

​	系统分配的进程组标识号

​	用户定义的进程名

​	用户定义的进程组名



###### 现场信息

用于存放该进程运行时的处理器现场信息

​	用户可见寄存器内容：数据寄存器、地址寄存器

​	控制与状态寄存器内容：PC、IR、PSW

​	栈指针内容：核心栈与用户栈指针



###### 控制信息

用于存放与管理、调度进程相关的信息

​	调度相关信息：状态、等待事件/原因、优先级

​	进程组成信息：代码/数据地址、外存映像地址

​	队列指引元：进程队列指针、父子兄弟进程指针

​	通信相关信息：消息队列、信号量、锁

​	进程特权信息：如内存访问权限、处理器特权

​	处理器使用信息：占用的处理器、时间片、处理器使用时间/已执行总时间、记账信息

​    资源清单信息：如正占有的资源、已使用的资源



##### 进程映像

Process Image

某一时刻进程的内容及其执行状态集合：

​	进程控制块：保存进程的标识信息、状态信息、控制信息

​	进程程序块：进程执行的程序空间

​	进程数据块：进程处理的数据空间，包括数据、处理函数的用户栈和可修改的程序

​	核心栈：进程在内核模式下运行时使用的堆栈，中断或系统过程使用

进程映像是内存级的物理实体，又称为进程的内存映像

![](D:\项目\markdown\操作系统\进程内存映像.png)



##### 进程上下文

Process context

进程的执行需要环境支持，包括CPU现场和Cache中的执行信息

OS中的进程物理实体和支持进程运行的环境合成进程上下文，包括以下：

​	用户级上下文：用户程序块/用户数据区/用户栈/用户共享内存

​	寄存器上下文：PSW/栈指针/通用寄存器

​	系统级上下文：PCB/内存区表/核心栈

 （用户程序，考虑用户级上下文、寄存器上下文；操作系统全考虑）

进程上下文刻画了进程的执行情况



#### 2.6.4 进程管理

关键的进程管理软件包括：

​	系统调用/中断/异常处理程序

​	队列管理模块

​	进程控制程序

​	进程调度程序（独立进程居多）

​	进程通信程序（多个程序包）

​	终端登录与作业控制程序、性能监控程序、审计程序等外围程序



##### 队列管理模块

队列管理模块是操作系统实现进程管理的核心模块

操作系统建立多个进程队列，包括就绪队列和等待队列

按需组织为先进先出队列与优先队列

队列中的进程可以通过PCB中的队列指引元采用单/双指引元或索引连接出队和入队操作

进程与资源调度围绕进程队列展开

###### 进程实现的队列模型

![](D:\项目\markdown\操作系统\进程实现的队列模型.png)

动态视频：2-10 3：06



##### 进程的控制与管理

###### 进程创建：

​	进程表加一项，申请PCB并初始化，生成标识，建立映像，分配资源，移入就绪队列

###### 进程撤销：

​	从队列中移除，归还资源，撤销标识，回收PCB，移除进程表项

###### 进程阻塞：

​	保存现场信息，修改PCB，移入等待队列，调度其他进程执行

###### 进程唤醒:

​	等待队列中移除，修改PCB，移入就绪队列（该进程优先级高于运行进程触发抢占）

###### 进程挂机：

​	修改状态出入相关队列，收回内存等资源送至对换区

###### 进程激活：

​	分配内存，修改状态并出入相关队列

###### 其他：

​	如修改进程特权



##### 原语与进程控制原语

进程控制过程中涉及对OS核心数据结构（进程表/PCB池/队列/资源表）的修改

为防止与时间有关的错误，应使用原语

原语是由若干指令构成的完成某种特定功能的程序，执行上具有不可分割性

原语的执行可以通过关中断实现

进程控制使用的原语称为进程控制原语

另一类常用原语是进程通信原语



#### 2.6.5 进程切换与模式切换

###### 进程切换

**进程切换指从正在运行的进程中收回处理器，让待运行进程来占有处理器运行**

进程切换实质上就是被中断运行进程与待运行进程的上下文切换，处理过程是：

​	保存被中断进程的上下文

​	转向进程调度

​	恢复待运行进程的上下文

必须在OS内核模式下完成，这需要模式切换



**工作过程：**

​	（中断/异常等触发）正向模式切换并压入PSW/PC

​		保存被中断进程的现场信息

​		处理具体中断/异常

​		把被中断进程的系统堆栈指针SP值保存到PCB

​		调整被中断进程的PCB，如进程状态

​		把被中断进程的PCB加入相关队列

​		选择下一个占用CPU运行的进程

​		修改被选中进程的PCB信息，如进程状态

​		设置被选中进程的地址空间，恢复存储管理信息

​		恢复被选中进程的SP值到处理器寄存器SP

​		恢复被选中进程的现场信息进入处理器

​		（中断返回指令触发）逆向模式转换并弹出PSW/PC



**发生时机：**

进程切换一定发生在中断/异常/系统调用处理过程中，常见的情况是：

​	阻塞式系统调用、虚拟地址异常导致被中断进程进入阻塞态

​	时间片中断、I/O中断后发现更高优先级进程导致被中断进程转入就绪态

​	终止用系统调用、不能继续执行的异常致被中断进程进程进入终止态



###### 模式切换

**处理器状态切换**

用户模式->内核模式

​	中断/异常/系统调用：中断用户进程执行而触发

内核模式到用户模式

​	OS执行中断返回指令：将控制权交还用户进程而出发



**基本工作任务：**

​	中断装置完成正向模式切换，包括：

​		处理器模式转为内核模式

​		保存当前进程的PC/PSW值到核心栈

​		转向中断/异常/系统调用处理程序

​	中断返回指令完成逆向模式转换，包括：

​		从待运行进程核心栈中弹出PSW/PC值

​		处理器模式转为用户模式



~~~
一些中断/异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交回给被中断进程，处理流程是：
	（中断/异常触发）正向模式切换压入PSW/PC
	保存被中断进程的现场信息
	处理中断/异常
	恢复被中断进程的现场信息
	（中断返回指令触发）逆向模式转换弹出PSW/PC
~~~



### 2.7 线程

#### 2.7.1 单线程结构进程

![](D:\项目\markdown\操作系统\单线程结构进程.png)

##### 问题

进程切换开销大

进程通信开销大

限制了进程并发的粒度

降低了并行计算的效率



#### 2.7.2 多线程结构进程

![](D:\项目\markdown\操作系统\多线程结构进程.png)

在多线程环境中，进程是操作系统中进行保护和资源分配的独立单位

​	用来容纳进程映像的虚拟地址空间

​	对进程、文件和设备的存取保护机制



线程是进程的一条执行路径，是调度的基本单位，同一个进程中的所有线程共享进程获得的主存空间和资源。它具有：

​	线程执行状态

​	受保护的线程上下文，当线程不运行时，用于存储现场信息

​	独立的程序指令计数器

​	执行堆栈

​	容纳局部变量的静态存储器



##### 线程的状态与调度

线程状态有运行、就绪和睡眠，无挂起

与线程状态变化有关的线程操作有：	

​	孵化、封锁、活化、剥夺、指派、结束

OS感知线程环境下

​	处理器调度对象是线程

​	进程没有三状态（或者说只有挂起）

OS不感知线程环境下：

​	处理器调度对象仍是进程

​	用户空间中的用户调度程序调度线程



##### 并发多线程程序设计的优点

快速线程切换

减少（系统）管理开销

（线程）通信易于实现

并行程度提高

节省内存空间



##### 多线程技术的应用：

前台和后台工作

C/S应用模式

加快执行速度

设计用户接口



### 2.8 KLT与ULT

#### 2.8.1 KLT

内核级线程 Kernel-Level Threads

线程管理的所有工作由OS内核来做

OS提供了一个应用程序设计接口API，供开发者使用KLT

OS直接调度KLT

![](D:\项目\markdown\操作系统\内核级线程.png)

##### 特点

进程中的一个线程被阻塞了，内核能调度同一进程的其它线程占有处理器运行

多处理器环境中，内核能同时调度同一进程中多个线程并行执行

内核自身也可用多线程技术实现，能提高OS的执行速度和效率

应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线城时需要模式切换，系统开销较大



#### 2.8.2 ULT

用户级线程，User-Level Threads

用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境工作由OS内核来做

任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行

线程管理的所有工作都由应用程序完成，内核没有意识到线程的存在

![](D:\项目\markdown\操作系统\用户级线程.png)



##### 特点

所有线程管理数据结构均在进程的用户空间中，线程切换不需要内核模式，能节省模式切换开销和内核的宝贵资源

允许进程按应用特定需要选择调度算法，甚至根据应用需求裁剪调度算法

能运行在任何OS上，内核在支持ULT方面不需要做任何工作

不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行

一个ULT的阻塞，将引起整个进程的阻塞。



为解决用户级线程的缺点，使用jacketing技术

##### Jacketing技术

​	把阻塞式系统调用改造成非阻塞式的

​	当线程陷入系统调用时，执行jacketing程序

​	由jacketing程序来检查资源使用情况，以决定是否执行进程切换或传递控制权给另一个线程



#### 2.8.3 二者对比

![](D:\项目\markdown\操作系统\ULTvsKLT.png)

##### 相同点

进程是资源保护的单位，在一个进程当中可以有多个线程，线程编程的接口是类似的，线程之间能够共享资源使得进程通信效果比较好

##### 不同点：

|      |                        用户级                         |         内核级         |
| :--: | :---------------------------------------------------: | :--------------------: |
| 调度 |      分为线程调度（用户来执行，切换快，可裁剪）       | 由OS来做的，通用的过程 |
|      |           和处理器调度（进程调度，OS执行）            |                        |
|      |          进程调度使用jacketing切换成线程调度          |                        |
| 适合 | 解决逻辑并行性问题（CAD软件中，一个工具影响别的工具） |   解决物理并行性问题   |



### 2.9 多线程实现的混合策略

线程创建是完全在用户空间做的

单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果

![](D:\项目\markdown\操作系统\多线程实现的混合式策略.png)



##### 特点

组合用户级线程/内核级线程设施

线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行（进程切换代价小）

一个应用中的多个用户级线程被映射到一些（小于等于用户级线程数目）内核级线程上

程序员可以针对特定应用和机器调节内核级线程的数目，以达到整体最佳结果

该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点



##### 混合策略下的线程状态

KLT三态，系统调度负责

ULT三态，用户调度负责

活跃态ULT代表绑定KLT的三态

活跃态ULT运行时可激活用户调度

非阻塞系统调用可使用jacketing启动用户调度，调整活跃态ULT

![](D:\项目\markdown\操作系统\混合策略下的线程状态.png)



### 2.10 处理器调度的层次

高级调度：又称长程调度，作业调度

​	决定能否加入到执行的进程池中

低级调度：又称短程调度，进程调度

​	决定哪个可用进程占用处理器执行

中级调度：又称平衡负载调度	

​	决定主存中的可用进程集合

![](D:\项目\markdown\操作系统\处理器调度层次与关键状态转换.png)

![](D:\项目\markdown\操作系统\处理器调度层次与关键状态转换2.png)



#### 高级调度

分时OS中，高级调度决定：

​	是否接受一个终端用户的连接

​	命令能否被系统接纳并构成进程

​	新建态进程是否加入就绪进程队列

批处理OS中，高级调度又称为作业调度，功能是按照某种原则从后备作业队列中选取作业进入主存，并为作业做好运行前的准备工作和完成后的善后工作



#### 中级调度

引进中级调度是为了提高内存利用率和作业吞吐量

中级调度决定那些进程被允许驻留在主存中参与竞争处理器及其他资源，起到短期调整系统负荷的作用

中级调度把一些进程换出主存，从而使之进入“挂起”状态，不参与进程调度，以平顺系统的负载



#### 低级调度

又称处理器调度、进程调度、短程调度，按照某种原则把处理器分配给就绪态进程或内核级线程

进程调度程序：又称分派程序，操作系统中实现处理器调度的程序，是操作系统的最核心部分

处理器调度策略的优劣直接影响到整个系统的性能

##### 主要功能

记住进程或内核级线程的状态

决定某个进程或内核级线程什么时候获得处理器，以及占用多长时间

把处理器分配给进程或内核级线程

收回处理器



### 2.11 处理器调度算法

##### 选择原则

资源利用率

​	使得CPU或其他资源的使用率尽可能高且能够并行工作

响应时间：

​	使交互式用户的响应时间尽可能小，或尽快处理实时任务

周转时间：

​	提交给系统开始到执行完成获得结果为止的这段时间间隔称为周转时间。

​	应该使周转时间或平均周转时间尽可能短

吞吐量：

​	单位时间处理的进程数尽可能多

公平性：

​	确保每个用户每个进程获得合理的CPU份额或其他资源份额



##### 优先数调度算法

根据分配给进程的优先数决定运行进程

​	抢占式优先数调度算法

​	非抢占式优先数调度算法

优先数的确定准则

​	进程负担任务的紧迫程度

​	进程的交互性

​	进程使用外设的频度



###### 与进入系统时间相关的优先数

计算时间短（作业/进程）优先

剩余计算时间短进程优先

响应比高者（作业。进程）优先

​	响应比=（等待时间+要求服务时间）/要求服务时间，一定大于1.

先来先服务：先进队先被选择

​	多用于高级调度；低级调度中，以计算为主的进程过于优越



##### 时间片轮转调度算法

根据各个进程进入就绪队列的时间，先后轮流占有CPU一个时间片

时间片中断

时间片的确定：选择长短合适的时间片，过长则退化为先来先服务算法，过短则调度开销大

单时间片，多时间片和动态时间片



##### 分级调度算法

又称多队列策略，反馈循环队列

基本思想

​	建立多个不同优先级的就绪进程队列

​	多个就绪进程队列间按照优先数调度

​	高优先级就绪进程，分配的时间片短

​	单个就绪进程队列中进程的优先数和时间片相同

![](D:\项目\markdown\操作系统\分级调度算法示例.png)



###### 分级原则

一般分级原则：

​	外设访问，交互性，时间紧迫程度，系统效率，用户立场

现代操作系统的实现模型

​	多个高优先级的实时进程队列，如：硬实时、网络、软实时

​	多个分时任务的进程队列，根据基准优先数和执行行为调整

​	队列树可多达32-128个



##### 彩票调度算法

为进程发放针对系统各种资源（如CPU时间）的彩票；当调度程序需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源

合作进程之间的彩票交换



## 3. 存储管理

### 3.1 存储管理的主要模式

#### 逻辑地址

又称相对地址，即用户编程所使用的地址空间

逻辑地址从0开始编号，有两种形式：

​	一维逻辑地址（段地址）

​	二维逻辑地址(段号：段内地址)



#### 段式程序设计

把一个程序设计成多个段：

​	代码段、数据段、堆栈段等等

用户可以自己应用段覆盖技术扩充内存空间使用量

​	这一技术是程序设计技术，不是OS存储管理的功能



#### 物理地址

又称绝对地址，即程序执行所使用的地址空间

处理器执行指令时，按照物理地址进行



#### 主存储器的复用

多道程序设计需要复用主存

按照分区复用：

​	主存划分为多个固定/可变尺寸的分区

​	一个程序/程序段占用一个分区

按照页架复用:

​	主存划分成多个固定大小的页架

​	一个程序/程序段占用多个页架



#### 存储管理的基本模式

##### 单连续存储管理：

​	一维逻辑地址空间的程序占用一个主存固定分区或可变分区

##### 段式存储管理：

​	段式二维逻辑地址空间的程序占用多个主存可变分区

##### 页式存储管理：

​	一维逻辑地址空间的程序占用多个主存页架区

##### 段页式存储管理：

​	段式二维逻辑地址空间的程序占用多个主存页架区

![](D:\项目\markdown\操作系统\存储管理模式示意图.png)



##### 分段与分页的区别

1、页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。 段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。

 2、页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。 段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。

 3、分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。 分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。



### 3.2 存储管理的功能

#### 3.2.1 地址转换

​	又称重定位，把逻辑地址转换成绝对地址

静态重定位：

​	在程序装入内存时进行地址转换（由装入程序执行，早期小型OS使用）

动态重定位：

​	在CPU执行程序时进行地址转换



#### 3.2.2 主存储器空间的分配与去配

分配：

​	进程装入主存时，存储管理软件进行具体的主存分配操作，并设置一个表格记录主存空间的分配情况



去配：

​	当某个进程撤离或主动归还主存资源时，存储管理软件要收回它所占用的全部或者部分存储空间，调整主存分配表



#### 3.2.3 主存储器空间的共享

多个进程共享主存储器资源：

​	多道程序设计技术使若干个程序同时进入主存储器，各自占用一定数量的存储空间，共同使用一个主存储器



多个进程共享主存储器的某些区域：

​	若干个协作进程有共同的主存程序块或者主存数据块



#### 3.2.4 存储保护

为避免主存中的多个进程相互干扰，必须对主存中的程序和数据进行保护

​	私有主存区中的信息：可读可写

​	公共区中的共享信息：根据授权

​	非本进程信息：不可读写



功能需要软硬件协同完成

​	CPU检查是否允许访问，不允许则产生地址保护异常，由OS进行相应处理



主存储器空间的扩充

存储扩充：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存

​	1.对换技术：把部分不运行的进程调出

​	2.虚拟技术：只调入进程的部分内容

这一工作需要软硬件协作完成：

​	1.兑换进程决定对换，硬件机构调入

​	2.CPU处理到不在主存的地址，发出虚拟地址异常，OS将其调入，重置指令



#### 3.2.5 虚拟存储器

主存容量限制带来诸多不便

​	用户编写程序必须考虑主存容量限制

​	多道程序设计的道数受到限制

用户编程行为分析

​	全面考虑各种情况，执行时有互斥性

​	顺序性和循环性等空间局部性行为

​	某一阶段执行的时间局部性行为

因此可以考虑部分调入进程内容



##### 基本思想

存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，以后根据执行行为随用随调入

如主存中没有足够的空闲空间，存储管理需要根据执行行为把主存中暂时不用的信息调出到辅存上去



##### 实现思路

需要建立与自动管理两个地址空间

​	（辅存）虚拟地址空间：容纳进程装入

​	（主存）实际地址空间：承载进程执行

对于用户，计算机系统具有一个容量大得多的主存空间，即虚拟存储器

虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能的程序设计



### 3.3 存储管理的硬件支撑

![](D:\项目\markdown\操作系统\存储器的组织层次.png) 



#### 3.3.1 存储对象

存储管理是OS管理主存储器的软件部分

为获得更好的处理性能，部分主存程序与数据（特别是关键性能数据）被调入Cache,存储管理需要对其进行管理，甚至包括对联想存储器的管理

为获得更大的虚拟地址空间，存储管理需要对存放在硬盘、固定硬盘、甚至网络硬盘上的虚拟存储器文件进行管理



#### 3.3.2 高速缓存存储器（Cache)

Cache是介入CPU和主存储器间的高速小容量存储器，由静态存储芯片SRAM组成，容量较小但比主存DRAM技术更加昂贵而快速，接近于CPU的速度



CPU往往需要重复读取同样的数据块，Cache的引入与缓存容量的增大，可以大幅提升CPU内部读取数据的命中率，从而提高系统性能



##### 构成：

由存储器、联想存储器、地址转换部件、替换逻辑等组成

联想存储器：

​	根据内容进行寻址的存储器

地址转换部件：

​	通过联想存储器建立目录表以实现快速地址转换。命中时直接访问Cache；未命中时从内存读取放入Cache

替换部件：

​	在缓存已满时按一定策略进行数据块替换，并修改地址转换部件



##### 分级：

![](D:\项目\markdown\操作系统\高速缓存存储器的组织.png)

L1 Cache:

​	分为数据缓存和指令缓存；内置；其成本最高，对CPU的性能影响最大；通常在32KB-256KB之间

L2 Cache:

​	分内置和外置两种，后者性能低一些；通常在512KB-8MB之间

L3 Cache:

​	多为外置，在游戏和服务器领域有效；但对很多应用来说，总线改善比设置L3更加有利于提升系统性能



#### 3.3.3 地址转换/存储保护的硬件支撑

![](D:\项目\markdown\操作系统\地址转换存储保护的硬件支撑.png)



#### 3.3.4 存储管理与硬件支撑

鉴于程序执行与数据访问的局部性原理，存储管理软件使用Cache可以大幅度提升程序执行效率

动态重定位、存储保护等，若无硬件支撑在效率上是无意义的，既无实现价值

无虚拟地址中断，虚拟存储器无法实现

无页面替换等硬件支撑机制，虚拟存储器在效率上是无意义的



### 3.4 单连续分区存储管理

每个进程占用一个物理上完全连续的存储空间（区域）

单用户连续分区存储管理

固定分区存储管理

可变分区存储管理



#### 3.4.1 单用户连续分区存储管理

适用于单用户单任务操作系统，如DOS

主存区域划分为系统区与用户区

​	系统区存放操作系统用的程序

​	用户区存放用户的进程

设置一个栅栏寄存器界分两个区域，硬件用它在执行时进行存储保护

一般采用静态重定位进行地址转换

​	在作业装入就把时把逻辑地址（指令地址、数据地址）全部转换成物理地址（绝对地址）

硬件实现代价低

![](D:\项目\markdown\操作系统\单用户连续分区存储管理.png)



#### 3.4.2 固定分区存储管理

支持多个分区

分区数量固定

分区大小固定

可用静态/动态重定位

硬件实现代价低

早期OS采用

![](D:\项目\markdown\操作系统\固定分区存储管理.png)

主存分配表

![](D:\项目\markdown\操作系统\固定分区主存分配表.png)

##### 主存分配与去配

###### **分配**

​	在分配表 找到能出容纳进程的最小分区记录

###### **去配**

​	去除这条记录



##### 地址转换

硬件实现机制与动态重定位

![](D:\项目\markdown\操作系统\固定分区方式动态重定位.png)



##### 问题

固定分区存储管理不够灵活，既不适应大尺寸程序，又存在内存**内零头**，有浪费

能否按照进程实际内存需求**动态划分分区**，并允许**分区个数可变**

引入可变分区存储管理



### 3.5 可变分区存储管理

按照进程的内存需求来动态划分分区

创建一个进程时，根据进程所需主存量查看主存中是否有足够的连续空闲空间

​	若有，则按需要量分割一个分区

​	若无，则令该进程等待主存资源

由于分区大小按照进程实际需要量来确定，因此分区个数是随机变化的



#### 3.5.1 内存分配示例

![](D:\项目\markdown\操作系统\可变分区方式的内存分配示例.png)

![](D:\项目\markdown\操作系统\可变分区方式的内存分配示例2.png)

![](D:\项目\markdown\操作系统\可变分区方式的内存分配示例3.png)

#### 3.5.2 主存分配表

已分配区表与未分配区表，采用链表

![](D:\项目\markdown\操作系统\可变分区方式的主存分配表.png)



#### 3.5.3 内存分配算法

##### 最先适应分配算法

​	在最前面找一个足够的分区，予以分配

##### 邻近适应分配算法

​	空闲区分配表组织成循环队列

##### 最优适应分配算法

​	找一个最小的能容纳的，容易产生小的无用的空闲分区

##### 最坏适应分配算法

​	找一个最大的，有利于两个分区都有用



#### 3.5.4 内存回收

![](D:\项目\markdown\操作系统\可变分区方式的内存回收.png)

![](D:\项目\markdown\操作系统\可变分区方式的内存回收2.png)



#### 3.5.5 地址转换与存储保护

硬件实现机制与动态重定位

![](D:\项目\markdown\操作系统\地址转换与存储保护.png)



#### 3.5.6 可变分区方式的内存零头

固定分区方式会产生内存内零头

可变分区方式也会随着进程的内存分配产生一些小的不可用的内存分配，称为内存外零头

最优适配算法最容易产生外零头

任何适配算法都不能避免产生外零头



#### 3.5.7 移动技术（程序浮动技术）

移动分区以解决内存外零头

需要动态重定位支撑

![](D:\项目\markdown\操作系统\移动技术.png)

![](D:\项目\markdown\操作系统\移动技术2.png)

![](D:\项目\markdown\操作系统\移动技术的工作流程.png)



### 3.6 页式存储

#### 3.6.1 基本原理

分页存储器将主存划分成多个大小相等的页架

受页架尺寸限制，程序的逻辑地址也自然分成**页**

不同的页可以放在不同页架中，不需要连续

**页表**用于维系进程的主存完整性

![](D:\项目\markdown\操作系统\进程页表.png)



#### 3.6.2 地址

对用户是透明的

##### 逻辑地址

页号和单元号



##### 物理地址

页架号和单元号



##### 地址转换

地址转换可以通过查阅页表完成

![](D:\项目\markdown\操作系统\页式存储管理的地址转换.png)



#### 3.6.3 内存分配与去配

可用一张**位示图**来记录主存分配情况

建立进程页表维护主存逻辑完整性

![](D:\项目\markdown\操作系统\页式存储位示图.png)

分配：总空闲块数够，找为0的位，如果不够，就采取策略

去配：把页架位从1变0



#### 3.6.4 页的共享

页式存储管理能够实现多个进程共享程序和数据

##### 数据共享：

​	不同进程可以使用不同页号共享数据页

##### 程序共享：

​	不同进程必须使用相同页号共享代码页



#### 3.6.5 页式存储管理的地址转换

##### 页式存储管理的地址转换代价

页表放在主存：每次地址转换必须访问两次主存

​	1.按页号读出页表中的相应页架号

​	2.按计算出来的绝对地址进行读写

存在问题：降低了存取速度

解决办法：利用了Cache存放部分页表



##### 快表

为提高地址转换速度，设置一个专用的高速存储器，用来存放页表的一部分

快表：存放在高速存储器中的页表部分

快表表项：页号，页架号

这种高速存储器是联想存储器，即**按照内容寻址**，而非按照地址访问



##### 引入快表后的地址转换代价

采用快表后，可以加快地址转换速度

假定主存访问时间为200毫微秒，快表访问时间为40毫微秒，查快表的命中率是90%，平均地址转换代价为：

（200 + 40） * 90% + （200 + 200） * 10%  = 256毫微秒

比两次访问主存的时间400毫微秒下降了36%



##### 基于快表的地址转换流程

按逻辑地址中的页号查快表

若该页已在快表中，则由页架号和单元号形成绝对地址

若该页不在快表中，则再查主存页表形成绝对地址，同时将该页登记到快表中

当快表填满后，又要登记新页时，则需在快表中按一定策略淘汰一个旧登记项



##### 多道程序环境下的进程表

进程表中登记了每个进程的页表

进程占有处理器运行时，其**页表起始地址和长度**送入**页表控制寄存器**

![](D:\项目\markdown\操作系统\多道程序环境下的进程表.png)



##### 多道程序环境下的地址转换

![](D:\项目\markdown\操作系统\多道程序环境下的地址转换.png)

①：进程占有了CPU之后，就占有了页表控制寄存器

②：就可以找到页表

③：逻辑地址首先和页表长度进行比较，如果越界，就产生越界中断

④⑤⑦：如果合法，就查询快表，形成页架号；

④⑥⑧：如果快表没有，查页表，形成页架号

⑨：把单元号移到绝对地址中，完整的绝对地址形成

⑩：访问主存



#### 3.6.6 页式虚拟存储管理

把进程全部页面装入虚拟存储器，执行时先把部分页面装入实际内存，然后，根据执行行为，动态调入不在主存的页，同时进行必要的页面调出

现代OS的主流存储管理技术

首次只把进程第一页装入主存，称为请求页式存储管理



##### 页式虚拟存储管理的页表

需要扩充页表项，指出：

​	每页的虚拟地址、实际地址

​	一系列标志：主存驻留标志、写回标志（修改后需要写回）、保护标志、引用标志（页面淘汰）、可移动标志（正在与外设交换，不可移动）

![](D:\项目\markdown\操作系统\页式虚拟存储的页表.png)



##### 实现

软硬件协同

###### CPU处理地址

​	若页驻留，则获得块号形成绝对地址

​	若页不在内存，则CPU发出缺页中断

###### OS处理缺页中断

​	若有空闲页架，则根据辅存地址调入页，更新页表与快表等

​	若无空闲页架，则决定淘汰页，调出已修改页，调入页，更新页表与快表



硬件部分示例

![](D:\项目\markdown\操作系统\页式虚拟存储管理的地址转换.png)

OS部分示例

![](D:\项目\markdown\操作系统\缺页中断的处理流程.png)



#### 3.6.7 页面调度

当主存空间已满而又需要装入新页时，页式虚拟存储管理必须按照一定的算法把已在主存的一些页调出去

选择淘汰页的工作称为**页面调度**

选择淘汰页的算法称为**页面调度算法**

页面调度算法如果设计不当，会出现（刚被淘汰的页面立即又要调入，并如此反复）这种现象称为**抖动**或**颠簸**



##### 缺页中断率

假定进程P共n页，系统分配页架数m个

P运行中成功访问次数为S，不成功访问次数为F，总访问次数A=S+F

**缺页中断率**定义为：f = F / A

缺页中断率是衡量存储管理性能和用户编程水平的重要依据



##### 影响缺页中断率的因素

分配给进程的页架数：

​	可用页架数越多，则缺页中断率就越低

页面的大小：

​	页面的尺寸越大，则缺页中断率就越低

用户的程序编制方法：

​	在大数据量情况下，对缺页中断率也有很大影响



###### 用户编程的例子

程序将数组置为“0”，假定仅分得一个主存页架，页面尺寸为128个字，数组元素按行存放，开始时第一页在主存。

![](D:\项目\markdown\操作系统\用户编程的例子.png)



##### OPT页面调度算法

最佳页面调度算法

当要调入新页面时，首先淘汰以后不再访问的页，然后选择距现在最长时间后再访问的页

OPT只可模拟，不可实现



##### FIFO页面调度算法

先进先出页面调度算法

总是淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页（常驻的除外）

模拟的是程序执行的顺序性，有一定合理性（但是程序不一定是顺序的，可能是循环的）



##### LRU页面调度算法

最近最少用页面调度算法

淘汰最近一段时间较久未被访问的那一页，即那些刚被使用过的页面，可能马上还要被使用到

模拟了程序执行的局部属性，既考虑了循环性又兼顾了顺序性

严格实现的代价大（需要维持特殊队列）



###### 模拟实现

每页建一个引用标志，供硬件使用

设置一个时间间隔中断：中断时页引用标志置0

地址转换时，页引用标志置1

淘汰页面时，从页引用标志为0的页中间随机选择

时间间隔多长是个难点（太短全是0，太长全是1）



##### LFU页面调度算法

最不常用页面调度算法

淘汰最近一段时间内访问次数较少的页面 对OPT的模拟性比LRU更好

基于时间间隔中断，并给每一页设置一个计数器

时间间隔中断发生后，所有计数器清0

每访问页1次就给计数器加1

选择计数值最小的页面淘汰



##### CLOCK页面调度算法

时钟调度算法

采用循环队列机制构造页面队列，形成了一个类似于钟表面的环形表

队列指针则相当于钟表面上的表针，指向可能要淘汰的页面

使用页引用标志位



###### 工作流程

页面调入主存时，其引用标志位置1

访问主存页面时，其引用标志为置1

淘汰页面时，从指针当前指向的页面开始扫描循环队列

​	把所遇到的引用标志为是1的页面的引用标志为清0，并跳过

​	把所遇到的引用标志为是0的页面淘汰，指针推进一步



#### 3.6.8 反置页表

##### 内存管理单元MMU

页表及相关硬件机制在地址转换、存储保护、虚拟地址访问中发挥了关键作用

OS为页式存储管理设置专门硬件机构

MMU：CPU管理虚拟/物理存储器的控制线路，把虚拟地址映射为物理地址，并提供存储保护，必要时确定淘汰页面

需要用到关键性数据结构：反置页表IPT



##### 基本设计思想

针对内存中的每个页架建立一个页表，按照块号排序

表项包含：正在访问该页架的进程标识、页号及特征位，和**哈希链指针**等

用来完成内存页架到访问进程页号的对应，即物理地址到逻辑地址的转换



##### 页表项

页号：虚拟地址页号

进程标志符：使用该页的进程号（页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页）

标志位：有效、引用、修改、保护和锁定等标志信息

链指针：哈希链



##### 基于反置页表的地址转换过程

MMU通过哈希表把进程标识和虚页号转换成一个哈希值，指向IPT的一个表目

MMU遍历哈希链找到所需进程的虚页号，该项的索引就是页架号，通过拼接位移便可生成物理地址

若遍历整个反置页表中未能找到匹配页表项，说明该页不在内存，产生缺页中断，请求操作系统调入

![](D:\项目\markdown\操作系统\反置页表地址转换示意.png)



### 3.7 段式存储管理

#### 3.7.1 段式存储管理

每个程序可由若干段组成，每一段都可以 从“0”开始编址，段内的地址是连续的

分段存储器的逻辑地址由两部分组成  段号和单元号

（段号+单元号用户自己设定的，页号+单元号系统设定的）

![](D:\项目\markdown\操作系统\程序的分段结构.png)



##### 基本思想：

段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区

硬件需要增加一组用户可见的段地址寄存器（代码段、数据段、堆栈段、附加段），供地址转换使用

存储管理需要增加设置一个段表，每个段占用一个段表项，包括：段始址、段限长，以及存储保护、可移动、可扩充等标志位



##### 地址转换流程：

![](D:\项目\markdown\操作系统\段式存储管理的地址转换流程.png)



##### 段的共享：

通过不同进程段表中的项指向同一个段基址来实现

对共享段的信息必须进行保护，如规定只能读出不能写入，不满足保护条件则产生保护中断

（没有相同段号这一具体要求）



#### 3.7.2 段式虚拟存储管理

##### 基本思想

把进程的所有分段都存放在辅存中，进程运行时先把当前需要的一段或几段装入主存，在执行过程中访问到不在主存的段时再把它们动态装入

段式虚拟存储管理中段的调进调出是由OS自动实现的，对用户透明

与段覆盖技术不同，它是用户控制的主存扩充技术，OS不感知



##### 段表扩充

​	特征位：00（不在内存）01（在内存）11（共享段）

​	存取权限：00（可执行）01（可读）11（可写）

​	扩充位：0（固定长）1（可扩充）

​	标志位：00（未修改）01（已修改）11（不可移动）

![](D:\项目\markdown\操作系统\段式虚拟存储的段表扩充.png)



##### 地址转换

![](D:\项目\markdown\操作系统\段式虚拟存储管理的地址转换.png)



#### 3.7.3 段页式存储管理

##### 基本思想

段式存储管理可以基于页式存储管理实现

每一段不必占据连续的存储空间，可存放在不连续的主存页架中

能够扩充位段页式虚拟存储管理

装入部分段，或者装入段中部分页面



##### 段表和页表

![](D:\项目\markdown\操作系统\段页式存储管理的段表和页表.png)



##### 地址转换

![](D:\项目\markdown\操作系统\段页式存储管理的地址转换.png)

![](D:\项目\markdown\操作系统\段式虚拟存储管理的地址转换2.png)

①：根据逻辑地址的段号页号去快表查

⑦：如果①查到，块号形成

②：如果①查不到，去段表查

③④：存储保护，比较

⑤：比较通过后，去段页表查

⑥：获得块号

⑧：拼接单元号，形成物理地址

⑨：访问主存



##### 段页式虚拟存储管理的地址转换

![](D:\项目\markdown\操作系统\段页式虚拟存储管理的地址转换.png)



## 4. 设备管理

### 4.1 设备管理概述

#### 4.1.1 I/O设备

又称输入输出设备、外围设备、外部设备、外设

​	用于计算机系统与外部世界（如用户、其他计算机或设备）的信息交换或存储



#### 4.1.2 I/O操作

内存和外设间的信息传送操作

​	影响计算机系统的通用性和可扩充性

​	影响计算机系统综合处理能力及性价比的重要因素



#### 4.1.3 I/O设备分类

##### 信息传输视角

###### 输入设备

将外界信息输入计算机，例如：键盘，鼠标，扫描仪等

###### 输出设备

将计算结果输出，例如：显示器，打印机等

###### 输入输出设备

输入信息并输出信息，例如：磁盘驱动器，网卡等

##### 交互功能视角

![](D:\项目\markdown\操作系统\交互功能IO设备.png)

##### 设备管理视角

![](D:\项目\markdown\操作系统\设备管理IO设备.png)



#### 4.1.4 设备管理目标

解决设备和CPU速度的不匹配，使主机和设备充分并行工作，提高设备使用效率

屏蔽设备的物理细节和操作过程，配置驱动程序，提供统一界面

​	抽象为裸设备

​	抽象为设备文件



##### 4.1.5 设备管理的功能

设备中断处理

缓冲区管理

设备的分配和去配

设备驱动调度

虚拟设备的实现



##### 4.1.6 设备管理的实现层次

###### I/O硬件

​	I/O设备及其接口线路

​	控制部件

​	通道

###### I/O软件

​	系统I/O软件

​	用户空间I/O软件



### 4.2 I/O控制方式

#### 4.2.1 设备控制器

设备控制器是CPU与设备之间的接口

![](D:\项目\markdown\操作系统\设备控制器.png)

##### 功能

接收和识别CPU或通道发来的命令

实现数据交换

发现和记录设备及自身的状态信息，供CPU处理时使用

当连接多台设备时，识别设备地址

##### 组成

![](D:\项目\markdown\操作系统\设备控制器的组成示意.png)



#### 4.2.2 轮询方式

处理器向控制器发出I/O命令，轮询I/O结果

若设备未就绪，则重复测试过程，直至设备就绪

执行内存数据交换

等待I/O操作完成后，处理器才可以继续其他操作

![](D:\项目\markdown\操作系统\IO控制的轮询方式.png)



#### 4.2.3 中断方式

处理器向控制器发出具体I/O命令，然后继续执行后续指令

​	若进程支持异步I/O，后续指令仍可是该进程中的指令

​	否则，该进程在这个中断上挂起，处理器执行其他工作

控制器检查设备状态，就绪后发出中断

CPU响应中断，进行中断处理

中断处理执行内存数据交换

![](D:\项目\markdown\操作系统\IO控制的中断方式.png)



#### 4.2.4 DMA方式

直接存储器访问

DMA模块

​	能够替代处理器来控制主存和设备控制器间的数据交换

![](D:\项目\markdown\操作系统\DMA模块.png)

##### 工作流程

处理器向DMA模块发出I/O命令

处理器继续执行其他工作，DMA模块负责传送全部数据

数据传送结束后，DMA中断处理器

![](D:\项目\markdown\操作系统\DMA工作流程.png)



##### 周期窃取

DMA和CPU同时通过总线访问内存，CPU会把总线的占有权让给DMA一个/几个主存周期

周期窃取对CPU与主存的数据交换影响不大

​	数据传送过程是不连续的和不规则的

​	CPU大部分情况下与Cache进行数据交换，直接访问内存较少

![](D:\项目\markdown\操作系统\DMA周期窃取.png)



#### 4.2.5 总结

| CPU作用  | 等待设备 | 内存数据交换 |
| :------: | :------: | :----------: |
| 轮询方式 |   需要   |     参与     |
| 中断方式 |  不需要  |     参与     |
| DMA方式  |  不需要  |    不参与    |

DMA：CPU只在I/O开始和结束时参与



#### 4.2.6 I/O通道

又称为通道控制器、I/O处理器，用于完成逻辑上独立的I/O任务

采用四级连接：处理器、通道、控制器、设备

​	通道可控制多台同类或不同类的设备

处理器不再执行I/O指令，而是在主存中 组织通道程序，由I/O通道执行



##### 工作流程

1.CPU遇到I/O任务，组织通道程序，置通道程序地址字CAW，启动指定通道程序，置通道程序地址字CAW，启动指定通道

2.通道从CAW获得通道程序，控制I/O设备进行操作，CPU执行其他任务

3.I/O操作完成后，I/O通道发出中断，CPU处理中断，并从通道程序状态字CSW获得通道执行情况，处理I/O操作

​	CPU与通道高度并行工作



#### 4.3 总线与I/O

总线：解决I/O速度不匹配问题

I/O和CPU速度，各设备I/O速度不匹配

使主机和设备充分并行，提高系统效率



##### 4.3.1 单总线结构

将CPU、主存和I/O模块连接到同一总线

优点：结构简单，易于扩充

缺点：共用总线；设备多时总线压力大，传输时延长，且慢速外设占用带宽多

![](D:\项目\markdown\操作系统\单总线结构模型.png)



##### 4.3.2 三级总线结构

主存和Cache通过主存总线连接，主存总线和扩展总线上的I/O设备间通过扩展总线接口缓冲

优点：主存与I/O之间的数据传送、处理器的内存活动分离；可以支持更多的I/O设备

缺点：不适用于I/O设备数据速率相差太大的情形

![](D:\项目\markdown\操作系统\三级总线模型.png)



##### 4.3.3 南桥与北桥

通过存储总线、PCI总线、E（ISA）总线分别连接主存、高速I/O设备和低速I/O设备

优点：可以支持不同数据速率的I/O设备

![](D:\项目\markdown\操作系统\南桥与北桥.png)



#### 4.3.4 一种基于通道的服务器总线模型

支持CPU、主存和多个I/O通道之间的数据传送

支持I/O通道和I/O控制器，以及I/O控制器和设备之间的数据传送

![](D:\项目\markdown\操作系统\一种基于通道的服务器总线模型.png)



### 4.3 I/O软件

#### 4.3.1 设计目标

![](D:\项目\markdown\操作系统\IO软件设计目标.png)



#### 4.3.2 设计要考虑的问题

设备无关性：

​	访问设备的程序与具体设备无关

出错处理：

​	低层软件能处理的错误不让高层软件感知

同步/异步传输：

​	支持阻塞和中断驱动两种工作方式

缓冲技术：

​	建立内存数据缓冲区，提高吞吐率



#### 4.3.3 层次结构

![](D:\项目\markdown\操作系统\IO软件的层次结构.png)



#### 4.3.4 中断处理程序

位于OS底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系

进程请求I/O操作时，通常被挂起

数据传输结束后产生I/O中断

CPU响应请求并转入中断处理程序



##### 功能

检查设备状态寄存器，并判断中断原因，根据I/O操作完成情况进行相应处理

​	如果数据传输有错，向上层软件报告设备的出错信息，实施重新执行

​	如果正常结束，唤醒等待传输的进程，使其转换为就绪态

​	如果有等待传输的I/O命令，通知相关软件启动下一个/O请求



#### 4.3.5 设备驱动程序

包括与设备密切相关的所有代码

从独立于设备的软件中接收I/O请求

把用户提交的逻辑I/O请求转化为物理I/O操作的启动和执行

监督设备是否正确执行，访问数据缓冲区，进行必要的纠错处理



##### 功能

设备初始化：

​	在设备传输数据时，预置设备、控制器以及通道状态

执行设备驱动例程：

​	负责启动设备，进行数据传输；对于通道，还负责组织通道程序，启动通道工作

执行与设备相关的具体中断处理：

​	负责处理设备、控制器及通道所发出的各种具体中断



##### 层次

每个设备驱动程序原则只处理一种设备，或者一类紧密相关的设备

设备驱动程序可以分层实现

​	高层/处理类设备，低层/处理具体设备

​	系统建立栈，接到I/O请求时先调用栈顶的驱动程序，然后继续向下调用低层驱动程序，直至所有物理操作被处理

​	这一方式使设备驱动的实现结构清晰、便于移植，但会增加一部分系统开销



#### 4.3.6 独立于设备的I/O软件

执行适用于所有设备的常用I/O功能，并向用户层软件提供一致性接口，包括：

​	设备命名：通过路径名寻址设备

​	设备保护：用户是否有权访问设备

​	提供与设备无关的数据单位：字符/块

​	缓冲技术：调整CPU与I/O速度不匹配

​	分配和状态跟踪：分配设备

​	错误处理/报告：驱动无法处理的错误



#### 4.3.7 用户空间的I/O软件

库函数：

​	一部分I/O软件可以使用库函数实现，放在操作系统内核之外，运行时与应用程序链接

虚拟设备软件：

​	用一类设备模拟另一类设备的仿真I/O软件



### 4.4 I/O缓冲区

#### 4.4.1 设置I/O缓冲的目的

解决CPU与设备之间速度不匹配的矛盾

协调逻辑记录大小和物理记录大小不一致的问题

提高CPU和设备的并行性

减少I/O操作对CPU的中断次数

放宽对CPU中断响应时间的要求



#### 4.4.2 I/O缓冲区

在内存中开辟的存储区，专门用于临时存放I/O操作的数据

##### 操作过程

###### 	写操作

将数据送至缓冲区，直到装满或需要写出，待适当时候系统将缓冲区内容写到设备上

###### 	读操作

系统将设备上的物理记录读至缓冲区，根据要求将当前所需要的数据从缓冲区读出并传送给进程



#### 4.4.3 单缓冲技术

OS在主存系统区中开设一个缓冲区

​	输入：先把数据读至缓冲区，再把缓冲区数据送至用户区，应用程序处理数据；如此往复，系统继续读入后继数据

![](D:\项目\markdown\操作系统\单缓冲技术.png)

​	输出：把数据从用户区传送到缓冲区，再将数据输出到设备，应用程序继续请求输出



#### 4.4.4 双缓冲技术

OS在主存系统区中开设两个缓冲区

​	输入：先把数据输入缓冲区1，再从缓冲区1把数据传到用户区，供应用程序处理；（同时设备可将数据传送到缓冲区2）

![](D:\项目\markdown\操作系统\双缓冲技术.png)

​	输出：先将数据从用户区传送到缓冲区1，再将数据传送到设备；（同时应用程序可将数据传送到缓冲区2）



#### 4.4.5 循环缓冲技术

OS分配一组缓冲区，每个缓冲区有指向下个缓冲区的链接指针，构成循环缓冲

​	继续调节设备和进程速度不匹配问题

![](D:\项目\markdown\操作系统\循环缓冲技术.png)



### 4.5 设备独立性

![](D:\项目\markdown\操作系统\设备独立性问题的提出.png)

![](D:\项目\markdown\操作系统\设备独立性及其实现.png)

![](D:\项目\markdown\操作系统\设备独立性的优点.png)



### 4.6 独占型外设的分配

独占型外设：一次只能由一个进程独占使用（键盘、显示器、打印机）

#### 4.6.1 设备分配方式

静态分配：进程运行前申请

​	实现简单，能够防止系统发生死锁，但会降低设备利用率

动态分配：进程随用随申请

​	提高设备利用率



#### 4.6.2 设备分配的数据结构

##### 设备表

​	每类设备都有各自的设备表，用来登记这类设备中的每台物理设备

​	包括：物理设备名，逻辑设备名，占有设备的进程，分配标志，好/坏标志等

##### 设备类表

​	每类设备对应于设备类表中的一栏

​	包括：设备类，总台数，空闲台数，设备表起始地址等

​	支持设备独立性时使用



### 4.7 磁盘

#### 4.7.1 磁盘结构

磁盘一般由多个扇片组成

每个盘片一般有两个盘面

盘面包括多个同心圆结构的磁道，不同盘面上位于相同位置的磁道构成柱面

每个磁道分为固定多个扇区，相邻扇区组合成簇

物理块地址：

​	1.柱面号，磁头号，扇区号

​	2.0面0道1扇区：面指盘面，不是柱面



#### 4.7.2 读写数据的方式

读写数据时，磁头必须定位到指定磁道上的指定扇区的开始处。过程如下：

​	寻道：控制移动臂到达指定柱面

​	旋转：等待要读写的扇区旋转到磁头下

​	选择磁头号，进行数据传送



#### 4.7.3 存取时间

磁盘存取时间完成数据读写所需要的时间

​	寻道时间+旋转延迟+传送时间

![](D:\项目\markdown\操作系统\磁盘存取时间.png)



#### 4.7.4 磁盘调度

磁盘可能同时接收到若干I/O请求

​	随机响应I/O请求，会得到很坏的性能

驱动调度:

​	OS的磁盘调度策略，即按照最佳次序执行处理访问磁盘的多个I/O请求，以减少磁盘访问的总处理时间

驱动调度策略包括：

​	移臂调度

​	旋臂调度



#### 4.7.5 移臂调度及算法

目的：使移动臂的移动时间按最短，从而减少寻道总时间

##### 移臂调度算法

先来先服务：移臂距离大，性能不好

最短查找时间优先（最小短距法）：

​	先执行查找时间最短的请求，具有较好的寻道性能

​	存在“饥饿”现象

##### 移臂调度的扫描算法

###### 单向扫描

​	移动臂向一个方向扫描，归途不提供服务，适用于不断有均匀分布的大量柱面请求的情形

###### 双向扫描

​	移动臂每次向一个方向移动，遇到最近的I/O请求便进行处理，到达最后一个柱面后再向相反方向移动

###### 电梯调度：

​	双向扫描的改进，当前移动方向没有访问请求时，就改变移动方向



#### 4.7.6 旋转调度

目的：使得旋转延迟的总时间最少

循环排序：

​	通过优化I/O请求排序，在最少旋转圈数内完成位于同一柱面的访问请求

​	旋转位置测定硬件和多磁头同时读写技术有利于提高旋转调度的效率

##### 优化分布

通过信息在存储空间的排列方式来减少旋转延迟

###### 交替排序：

​	由于磁盘匀速运转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，如交叉因子为n:1表示相邻编号间会间隔n-1个扇区

把相邻扇区集中成簇读写

按柱面集中存储数据（另一种集簇方式），可以减少数据读写时的移臂操作



### 4.8 SPOOLing系统

#### 4.8.1 虚拟设备技术

使用一类物理设备模拟另一类物理设备的技术

示例：

​	内存卡模拟磁盘，块设备模拟字符设备，输入输入重定向



#### 4.8.2 一个经典的SPOOLing系统

用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间

慢速输入设备先输入到（输入井）

慢速输出设备先输出到（输出井）

进程运行过程中只从输入井读入数据，只想输出井输出信息，使得全部I/O都基于磁盘

加快进程周转时间，提高系统吞吐量



##### 软件组成

预输入程序：预先把数据从输入设备传送到磁盘输入井

缓输出程序：把数据从磁盘输出井传送到输出设备

井管理程序：控制进程和井之间的数据交换（事实上是I/O重定向）



##### 示意图

![](D:\项目\markdown\操作系统\SPOOLing示意图.png)

![](D:\项目\markdown\操作系统\SPOOLing示意图2.png)



#### 4.8.3 打印SPOOLing系统

打印机守护进程和SPOOLing打印目录

​	守护进程是唯一有特权使用打印机设备的进程

​	打印文件前，用户进程先产生完整的待输出文件，并存放在打印目录下

​	打印机空闲时，启动守护进程，打印待输出文件



### 4.9 批处理系统的作业管理

#### 4.9.1 SPOOLing系统与作业管理

![](D:\项目\markdown\操作系统\SPOOLing系统与作业管理.png)



#### 4.9.2 多道批处理OS的作业管理

作业说明语言：用于作业控制的语言

作业说明书：刻画具体作业的控制方式

作业状态：输入状态（预输入）、后备状态（空闲）、运行状态（运行）、完成状态（缓输出）

作业调度：从后被状态作业中选择部分进入运行状态（前提是资源满足）

作业调度算法：优先数、短作业、响应比、设备搭配、等等



## 5. 文件管理

### 5.1 文件的概念

![](D:\项目\markdown\操作系统\文件的概念.png)

#### 5.1.1 文件的命名

![](D:\项目\markdown\操作系统\文件的命名.png)

#### 5.1.2 文件的分类

![](D:\项目\markdown\操作系统\文件的分类.png)

#### 5.1.3 引入文件的优点

![](D:\项目\markdown\操作系统\引入文件的优点.png)

![](D:\项目\markdown\操作系统\引入文件的优点2.png)



### 5.2 文件系统的概念

![](D:\项目\markdown\操作系统\文件系统的概念.png)

![](D:\项目\markdown\操作系统\文件系统中的文件.png)



#### 5.2.1 文件系统的功能

文件系统面向用户的功能是：

​	文件的按名存取

​	文件的共享和保护

​	文件的操作和使用

为了实现这些功能，OS必须考虑：

​	文件目录的建立和维护

​	存储空间的分配和回收

​	数据的保密和保护

​	监督用户存取和修改文件的权限

​	实现在不同存储介质上信息的表示方式、编制方法、存储次序、以及信息检索等问题 



#### 5.2.2 文件系统的组成

![](D:\项目\markdown\操作系统\文件系统的组成.png)



### 5.3 文件的存储

#### 5.3.1 卷和块

文件存储介质有磁带、光盘和磁盘

卷是存储介质的物理单位，对应于一盘磁带、一块软盘、一个光盘片、一个硬盘分区

块是存储介质上连续信息所组成的一个区域，也叫做物理记录

块在主存储器和辅助存储区进行信息交换的物理单位，每次总是交换一块或整数块信息

![](D:\项目\markdown\操作系统\卷和块.png)



#### 5.3.2 顺序存取设备

顺序存取设备是严格依赖信息的物理位置次序进行定位和读写的存储设备

![](D:\项目\markdown\操作系统\磁带机.png)

光盘也是一种顺序存取存储设备



#### 5.3.3 直接存取存储设备

![](D:\项目\markdown\操作系统\磁盘.png)



### 5.4 文件的逻辑结构

逻辑文件，又称为文件的逻辑结构

​	独立于物理环境的，用户概念中的抽象信息组织方式

​	用户能观察到的，并加以处理的数据集合

文件的逻辑结构分为两种形式

​	一种是基于字节的流式文件

​	一种是基于记录的记录式文件



#### 5.4.1 流式文件

流式文件指文件内的数据不再组成记录，只是由一串依次的字节组成的信息流序列

这种文件常常按长度来读取所需信息，也可以用插入的特殊字符作为分界



#### 5.4.2 记录式文件

记录式文件是一种有结构的文件，它是若干逻辑记录信息所组成的记录流文件

逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位

如，每个职工的工资信息是一个逻辑记录；整个单位职工的工资信息便组成了该单位工资信息的记录式文件

![](D:\项目\markdown\操作系统\记录式文件.png)

##### 记录式文件与数据库

![](D:\项目\markdown\操作系统\记录式文件与数据库.png)



### 5.5 文件的物理结构 	

文件的物理结构和组织是指文件在物理存储空间中的存放方法和组织关系

又称为物理文件

文件的存储结构涉及块的划分、记录的排列、索引的组织、信息的搜索等许多问题

其优劣直接影响文件系统的性能



#### 5.5.1 顺序文件

将一个文件中逻辑上连续的信息存放到存储介质的依次相邻的块中便形成顺序结构，这类文件叫顺序文件，又称连续文件

磁带文件、光盘文件是典型例子

##### 优缺点

优点：顺序存取记录时速度较快

​	批处理文件，系统文件用得最多

​	采用磁带存放顺序文件时，总可以保持快速存取

缺点：建立文件前需要能预先确定文件长度，以便分配存储空间；修改、插入和增加文件记录有困难



#### 5.5.2 连接文件

连接文件，又称串联文件；连接结构的特点是使用连接字来表示文件中各个物理块之间的先后次序

第一块文件信息的物理地址由文件目录给出，而每一块的连接字指出了文件的下一个物理块位置；连接字内容为0时，表示文件至本块结束

像输入井、输出井等都用此类文件

![](D:\项目\markdown\操作系统\连接文件.png)

##### 优缺点

优点：易于对文件记录做增删改，易于动态增长记录；不必预先确知文件长度；存储空间利用率高

缺点：存放指针需额外的存储空间；由于存取须通过缓冲区，待获得连接字后，才能找到下一物理块的地址，因而，仅适用于顺序存取



#### 5.5.3 直接文件

又称为散列文件，它通过计算记录的关键字建立与其物理存储地址之间的对应关系

这种变换通常采用散列法

计算寻址结构可能出现“冲突”，即不同的关键字可能变换出相同的地址来，解决办法有拉链法，循环探查法、二次散列法、溢出区法等



#### 5.5.4 索引文件

索引文件为每个文件建立了一张索引表，其中，每个表目包含一个记录的键（或逻辑记录号）及其存储地址

索引表的地址可由文件目录指出，查阅索引表先找到相应记录键（或逻辑记录号），然后获得数据存储地址



##### 访问方式

索引文件在文件存储器上分两个区：索引区和数据区

访问索引文件需两步操作：第一步查找索引表，第二步获得记录物理地址

需要两次访问辅助存储器，若文件索引已预先调入主存储器，那么，就可减少一次内外存信息交换



##### 优缺点

优点：索引结构可以被认为是连接结构的一种扩展，除了具备连接文件的优点外，还克服了它只能作顺序存取的缺点，具有直接读写任意一个记录的能力，便于文件的增、删、改

缺点：增加了索引表的空间开销和查找时间



##### 组织

![](D:\项目\markdown\操作系统\一种多级索引结构.png)



### 5.6 文件的目录结构

#### 5.6.1 概念

是实现文件的“按名存取”的关键数据结构

文件系统的基本功能之一就是负责文件目录的建立、维护和检索，要求编排的目录便于查找、防止冲突

文件目录需要永久保存，因此也组织成文件存放在磁盘上，称目录文件



#### 5.6.2 一级目录结构

在操作系统中构造一张线性表，与每个文件的相关属性占用一个目录项，构成了一级目录结构

由于用户与文件众多，容易重名，不利记忆



#### 5.6.3 二级目录结构

第一级为主文件目录，它用于管理所有用户文件目录，它的目录项登记了系统接受的用户的名字及该用户文件目录的地址

第二级为用户的文件目录，它为该用户的每个文件保存一个登记栏，其内容与一级目录的目录项相同

每一用户只允许查看自己的文件目录

![](D:\项目\markdown\操作系统\二级目录结构.png)



##### 特点

采用二级目录管理文件时，因为任何文件的存取都通过主文件目录，于是可以检查访问文件者的存取权限，避免一个用户未经授权就存取另一个用户的文件，使用户文件的私有性得到保证，实现了对文件的保密和保护

特别是不同用户具有同名文件时，由于各自有不同的用户文件目录而不会导致混乱

对于同一个用户而言，同样存在文件多、容易重名问题



#### 5.6.4 树形目录结构

每一级目录可以登记下一级目录，也可以登记文件，从而形成了层次文件目录结构

层次目录结构通常采用树形目录结构，它是一棵倒向的有根树，树根是根目录；从根向下，每一个树分叉是一个子目录；而树叶是文件



##### 特点

较好地反映现实世界中具有层次关系的数据集合和较确切地反映系统内部文件的组织结构

不同文件可以重名，只要它们不位于同一末端的子目录中

易于规定不同层次或子树中文件的不同存取权限，便于文件的保护、保密和共享



##### 文件定位

一个文件的全名包括从根目录开始到文件为止，通路上遇到的所有子目录路径，又称为路径名

各子目录名之间用正斜线/（反斜线\）隔开

一个硬盘分区可以组织成一颗子树

​	每颗子树可以对应于一个逻辑盘符（Win）

​	也可以把众多子树嫁接成一颗大树（UNIX）

![](D:\项目\markdown\操作系统\UNIX树形目录结构.png)



### 5.7 文件目录的管理

#### 5.7.1 文件查找

是文件目录管理的重要工作。“按名存取”文件就是系统根据用户提供的文件路径名来搜索各级文件目录，找到该文件

​	可以从根目录查起（绝对路径名）

​	亦可以从“当前目录”查起（相对路径名），用.表示当前目录,..表示父目录

​	现在操作系统都设置有改变工作目录命令，即变更当前工作目录



#### 5.7.2 目录项查找

搜索具体目录项时，可以采用顺序查找法，依次扫描文件目录中的目录项，将目录项中的名字与欲查找的文件名相比较

可以采用一些优化办法加快查找目录的速度

​	目录表项是按键的顺序编排，则可以采用“二分查找法”

​	或者采用“杂凑法”，把每个文件名经过变换函数变换成唯一的目录表表项



#### 5.7.3 文件目录处理

树形目录结构存在的一个问题：当一个文件经过许多目录节点时，很不方便；多次访问文件存储器，使访问速度大大减慢

若把所有文件的目录都复制到主存，访问速度是加快了，但又增加了主存的开销

一种有效办法是把常用和正在使用的那些文件目录复制进主存，这样，既不增加太多的主存开销，又可明显减少目录查找时间

##### 活动文件表

系统为每个用户进程建立一张活动文件表

当用户使用一个文件之前，先通过“打开”操作，把该文件有关目录信息复制到指定主存区域，有关信息填入活动文件表，以建立用户进程和该文件索引的联系

当不再使用该文件时，使用“关闭”，切断用户进程和这个文件的联系，同时，若该目录已被修改过，则应更新辅存中对应的文件目录



### 5.8 文件安全和保护

#### 5.8.1 文件的安全和保护

![](D:\项目\markdown\操作系统\文件的安全与保护.png)



#### 5.8.2 文件共享

是计算机用户完成共同任务所必需的

有许多好处，如：减少用户大量重复性劳动；免除系统复制文件的工作；节省文件占用的存储空间；减少程序设计输入输出文件的次数



##### 并发控制

在允许文件共享的系统中，OS应提供手段实现对共享文件的同步控制

多个进程可能同时存取一个文件，如果他们同时进行读操作，OS应对文件进行公用控制

如果有进程进行写操作，例如，有两个进程，进程A要求修改文件，进程B要求读出同一文件的数据，则OS必须提供同步控制机制，以保证文件数据的完整性



#### 5.8.3 文件的保密

文件及其内容不能被未经文件主授权的其他用户窃取

文件的保密措施有以下几种：

​	隐藏文件目录

​	设置口令

​	使用密码（避免直接从磁盘块窃取）



### 5.9 文件的保护

防止文件被破环

OS必须提供文件保护机制，有效实现文件的完整性

常用的文件保护方法：

​	文件副本

​	文件存取矩阵与文件存取表

​	文件属性

#### 5.9.1 文件的副本

文件系统必须要有防止硬软件故障，保存信息完整性的能力

文件副本是主要实现机制

​	动态多副本技术

​	转储、备份、恢复



##### 动态多副本

在多个介质上维持同一内容的文件，并且在更新内容时同时进行

需要增加设备费用和系统负载

一般适用于容量较小且较为重要的文件，例如不需要新的系统文件及专用文件，当文件发生故障时只要切换到备用设备就可（例如：系统文件）



##### 文件转储

定时把文件复制转储到其他介质上，当某介质上出现故障时，复原转储文件

转储又可分成两种方式：

​	一、在一定时间间隔或一个单位处理结束时，系统自动复写更新过的文件和数据

​	二、每天或每周把文件信息全部复写一遍，需要时再通过装入转储文件来恢复系统，诸如BACKUP、RESTORE等命令



##### 文件的存取控制矩阵

系统为每个用户设置访问每个文件对象的存取属性

系统的全部用户对全部文件的存取属性就组成一个二维矩阵，称为存取控制矩阵



##### 存取控制表

由于OS拥有很多用户和众多文件，存取控制矩阵是一个稀疏矩阵，可以将其简化为一张存取控制表

每行包括：用户、文件、存取属性

存取控制表仅登记那些对文件拥有存取属性的部分



#### 5.9.2 基于存取控制矩阵/表的文件保护

存取属性：可以有访问、读、写、执行、创建、删除、授权等等

系统通过查阅（矩阵/表）核对用户对文件的存取权限

文件属主使用GRAND、REVOKE等命令进行授权，甚至把授权权转授给其他信任的用户

系统管理用户（超级用户）等同于文件属主权限，并获得对系统文件的授访问权权限



#### 5.9.3 文件属性

存取控制表的一种简化方法是用户分类，再针对每类用户规定文件属性

用户分类：属主、合作者、其他

文件属性：读、写、执行、。。。

文件属性可以放在文件目录项中，管理大为简化

用户使用文件时，通过核对文件属性，实现保护

![](D:\项目\markdown\操作系统\文件属性.png)



### 5.10 文件的存取方法

OS为用户程序提供的使用文件的技术和手段

文件存取方法在某种程度上依赖于文件的物理结构

#### 5.10.1  顺序存取

按记录顺序进行读/写操作的存取方法

读操作根据读指针读出当前记录，同时推进读指针，指向下一次要读出的记录

写操作则设置写指针，把一个记录写到文件末端，同时推进写指针

允许对读指针进行前跳或后退n个记录的操作



#### 5.10.2 直接存取

很多应用场合要求快速地以任意次序直接读写某个记录

例如，航空订票系统，用航班号作标识，把特定航班的所有信息存放在物理块中，用户预定某航班时，直接计算出该航班的存位置



#### 5.10.3 索引存取

基于索引文件的索引存取方法

对于这种文件，信息块的地址都可以通过查找记录键而换算出

除可采用按键存取外，也可以采用顺序存取或直接存取的方法

实际的系统中，大都采用多级索引，以加速记录查找过程



### 5.11 文件的使用

用户通过两类接口与文件系统联系

一、与文件有关的操作命令

​	例如：cat,cd,cp,find,mv,rm,mkdir,rmdir

二、提供给用户程序使用的文件类系统调用，基本文件类系统调用有：

​	建立、打开、读/写、定位、关闭、撤销



#### 5.11.1 建立文件

用于创建一个文件

所需参数：文件名、设备类（号）、文件属性及存取控制信息

处理流程：在相应设备上建立一个文件目录项，为文件分配第一个物理块，在活动文件表中申请一个项，登记有关目录信息，并返回一个文件句柄



#### 5.11.2 撤销文件

用于删除一个文件

所需参数：文件名、设备类（号）

处理流程：若文件没有关闭，先关闭文件；若为共享文件，进行联访处理；在目录文件中删去相应目录项；释放文件占用的文件存储空间



#### 5.11.3 打开文件

用于建立起文件和用户进程之间的使用联系

所需参数：文件名、设备类（号）、打开方式

处理流程：在主存活动文件表中申请一个项，返回一个文件句柄；根据文件名查找目录文件，把目录信息复制到活动文件表相应栏；按存取控制说明检查访问的合法性；若打开的是共享文件，则应有相应处理



#### 5.11.4 关闭文件

用于结束一个文件的读写

所需参数：文件句柄

处理流程：将活动文件表中该文件的”当前使用用户数“减1；若此值为0，则收回此活动文件表；完成”推迟写“；若活动文件表目内容已被改过，则应先将表目内容写回文件存储器上相应表目中，以使文件目录保持最新状态



#### 5.11.5 读写文件

用于读写文件

所需参数：文件句柄、用户数据区地址、读写的记录或字节个数

处理流程：按文件句柄从活动文件表中找到该文件的目录项信息；根据目录项指出的该文件的逻辑和物理组织方式，把相关逻辑记录转换成物理块



#### 5.11.6 定位文件

用于调整所打开文件的读写指针位置

所需参数：文件句柄、定位指针



### 5.12 辅存空间管理

![](D:\项目\markdown\操作系统\辅存空间管理.png)



#### 5.12.1 分配方式

##### 连续分配

存放在辅存空间连续存储区中（连续的物理块号）

优点是顺序访问时速度快，管理较为简单，但为了获得足够大的连续存储区，需定时进行’碎片‘整理

##### 非连续分配

动态分配给若干扇区或簇（几个连续扇区）不要求连续

优点是辅存空间管理效率高，便于文件动态增长和收缩



#### 5.12.2 空闲块的管理：位示图

使用若干字节构成一张表，表中每一字位对应一个物理块，字位的次序与块的相对次序一致。字位为’1‘表示相应块已占用，字位为’0‘状态表示该块空闲

优点是：可以把位示图全部或大部分保存在主存中，再配合现代计算机都具有的位操作指令，可实现高速物理块分配和去配



#### 5.12.3 空闲块的管理：空闲块成组连接法

![](D:\项目\markdown\操作系统\空闲块成组连接法.png)

![](D:\项目\markdown\操作系统\空闲块成组连接法的分配归还.png)



### 5.13 文件系统的实现

![](D:\项目\markdown\操作系统\文件系统的实现层次.png)



## 6. 并发程序设计

### 6.1 概念

#### 6.1.1 顺序程序设计

程序是实现算法的操作（指令）序列

每个程序在处理器上执行是严格有序的

成为程序执行的内部顺序性

程序设计的一般习惯是顺序程序设计

​	把一个具体问题的求解过程设计成一个程序或若干严格顺序执行的程序序列

​	这成为程序执行的外部顺序性

##### 特性

程序执行的顺序性：程序指令执行是严格按序的

计算环境的封闭性：程序运行时如同独占受操作系统保护的资源

计算结果的确定性：程序执行结果与执行速度和执行时段无关

计算过程的可再见性：程序对相同数据集的执行轨迹是确定的



#### 6.1.2 进程的并发设计

多道程序设计让多个程序同时进入内存去竞争处理器以获得运行机会

OS允许计算机系统在一个时间段内存在多个正在运行的进程，即允许多个进程并发执行

OS保证按照“顺序程序设计”方法编制的程序在并发执行时不受影响，如同独占计算机

这些按照顺序程序设计思想编制的进程在OS中并发执行属于无关的并发进程

![](D:\项目\markdown\操作系统\并发程序设计引入例.png)

处理器利用率≈52/（78 + 52 + 20） = 35%



![](D:\项目\markdown\操作系统\并发程序设计引入例2.png)



#### 6.1.3 并发程序设计

把一个具体问题求解设计成若干个可同时执行的程序模块的方法

##### 特性

**并行性：**多个进程在多道程序系统中并发执行或者在多处理器系统中并行执行

​				提高了计算效率

**共享性：**多个进程共享软件资源

**交往性：**多个进程并发执行时存在制约

​			    增加了程序设计的难度



### 6.2 并发进程的制约关系

#### 6.2.1 无关与交往的并发进程

无关的并发进程：一组并发进程分别在不同的变量集合上运行，一个进程的执行与其他并发进程的进展无关

交往的并发进程：一组并发进程共享某些变量，一个进程的执行可能影响其他并发进程的结果



#### 6.2.2 与时间有关的错误

对于一组交往的并发进程，执行的相对速度无法相互控制

如果程序设计不当，可能出现各种“与时间有关的”错误

##### 表现一：结果错误

案例：机票问题

![](D:\项目\markdown\操作系统\机票问题.png)



##### 表现二：永远等待

![](D:\项目\markdown\操作系统\内存管理问题.png)



#### 6.2.3 进程互斥与同步

交互的并发进程在执行时必须进行制约，才能保证得到合理的结果

##### 进程互斥：

​	并发进程之间因相互争夺独占性资源而产生的竞争制约关系

##### 进程同步：

​	并发进程之间为完成共同任务基于某个条件来协调执行先后关系而产生的协作制约关系



### 6.3 临界区

#### 6.3.1 互斥与临界区

**临界资源：**互斥共享变量所代表的资源，即一次只能被一个进程使用的资源

​		硬件：打印机、磁带机等

​		软件：消息缓冲队列、变量、数组、缓冲区

​		诸进程间应该采取互斥方式，实现对这种资源的共享。



**临界区：**指并发进程中与互斥共享变量相关的程序段

多个并发进程访问临界资源时，存在竞争制约关系

如果两个进程同时停留在相关的临界区内，就会出现与时间相关的错误                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               



#### 6.3.2 概念

确定临界资源 shared<variable>

确定临界区 region <variable> do <statement_list>

两个进程的临界区有相同的临界资源，就是**相关的临界区**，必须互斥进入

两个临界区不相关，进入就没有限制



#### 6.3.3 临界区管理的三个要求

一次至多允许一个进程停留在相关的临界区内

一个进程不能无限止地停留在临界区内

一个进程不能无限止地等待进入临界区



#### 6.3.4 临界区的嵌套使用

![](D:\项目\markdown\操作系统\临界区的嵌套使用.png)

但如果两个联合使用

![](D:\项目\markdown\操作系统\临界区的嵌套使用2.png)

当进程1进入X之后，发生中断，进程二进入Y之后，就无法进入X，产生死锁，同时，进程X也无法进入Y。

### 6.4 临界区管理实现的尝试

#### 6.4.1 尝试一

先检测再挂锁

设两个变量inside1 ，inside2表示进程1，进程2是否在临界区内

初始两个变量全是false;

当进程1进入时，先inside == true,为真 则等待，为假则inside = true 进程1进入临界区，出来后inside = false;

进程2同理

![](D:\项目\markdown\操作系统\临界区管理：尝试一.png)

会出现P1,P2同时进入的情况



#### 6.4.2 尝试二

先挂锁，再检测

![](D:\项目\markdown\操作系统\临界区管理：尝试二.png)

会出现P1,P2同时进不去的情况



#### 6.4.3 解决思路

框内的（测试锁、建立锁）两条指令执行过程不能中断

把测试锁和建立锁合并成一条指令——测试并建立指令

![](D:\项目\markdown\操作系统\解决思路.png)



### 6.5 临界区管理实现的硬件方法

#### 6.5.1 测试并建立指令

~~~c
TS(x){
	if(x==false){
		x = true;
		return ture;
	}else{
	return false;
	}
}
~~~

~~~java
Boolean lock;
lock = false;                           //临界区可用
process Pi{								//i = i,2,...,n
	Boolean pi;
	repeat pi = TS(lock) until pi;      //循环请求锁
   	临界区;
	lock = false;                        //解锁
}
~~~



#### 6.5.2 对换指令

~~~c
swap(a,b){
	temp = a;
	a = b;
	b = temp;
}
~~~

~~~
Boolean lock;
lock = false;                      //临界区可用
process Pi{                         //i = 1,2,...,n
	Boolean pi;
	pi = true;
	repeat swap(lock,pi) until !pi; // 循环请求锁
	临界区；
	lock = false;                   //解锁	
}
~~~



#### 6.5.3 实现临界区管理的硬件设施

TS和swap指令均是忙式等待（如果进不去循环测试），效率低

简单的解决办法是在进出临界区时开关中断，这样临界区执行就不会中断了，执行就有原子性

​	**关中断；临界区；开中断**

操作系统原语就采用这种实现思路

但是，临界区的指令长度应该短小精悍，这样才能保证OS的使用效率

不建议用户程序使用，滥用是可怕的！



### 6.6 PV操作与进程互斥

#### 6.6.1 问题的提出

TS或swap指令管理临界区，采用忙式轮询，效率低

关开中断管理临界区，不便交给用户程序使用

参考：OS访问硬件资源时采用“请求-等待-中断恢复”方式



#### 6.6.2 信号量的构思

一种可动态定义的软件资源：信号量

​	核心数据结构：等待进程队列

​	信号量声明：资源报到，建立队列

​	申请资源的原语：若申请不得，调用进程入队等待

​	归还资源的原语：若队列中有等待进程，需释放

​	信号量撤销：资源注销，撤销队列



#### 6.6.3 记录型信号量的定义

记录型信号量：一种带数值的软资源

~~~c
typedef struct semaphore{
	int value;             //信号量值
	struct pcb * list;     //信号量等待进程队列指针
}
~~~

每个信号量建立一个等待进程队列

每个信号量相关一个整数值

​	正值表示资源可重复次数（临界资源初值一定是1）

​	0值表示无资源且无进程等待

​	负值表示等待队列中进程个数



#### 6.6.4 PV操作解决进程互斥问题框架

##### P原语（申请资源）

~~~c
procedure P(semaphore:s){
	s = s - 1;                //信号量减去1
	if(s < 0)                 //若信号量小于0
        W(s);                 //则调用进程，被置成等待信号量S的状态
}
~~~



##### V原语（归还资源）

~~~c
procedure V(semaphore:s){
	s = s + 1;              //信号量加1
	if(s <= 0)              //若信号量小于等于0
		R(s)；              //则释放一个等待信号量s的进程
}
~~~



##### PV操作解决进程互斥问题框架

~~~c
semaphore s;
s = 1;
cobegin
	process Pi{
		......
		P(s);
		临界区；
		V(s);
		......
	}
coend;	
~~~



#### 6.6.5 PV操作解决机票问题

~~~c
int A[m];
Semaphore s;
s = 1;
cobegin
	process Pi{
		int Xi;
		Li:按旅客订票要求找到A[j];
		P(s);
		Xi = A[j];
		if(Xi >= 1){
			Xi = Xi - 1;
			A[j] = Xi;
			V(s);
			输出一张票；
		}else{
			V(s);                //P操作与V操作在执行路径上一一匹配
			输出票已售完；
		}
		goto Li;
	}
coend	
~~~

只有相同航班的票数才是相关的临界资源，所以用一个信号量处理全部机票会影响进程并发度。



#### 6.6.6 PV操作解决机票问题（改进）

~~~c
int A[m];
Semaphore s[m];
for(itn j = 0; j < m;j++)
	s[j] = 1;

cobegin
	process Pi{
		int Xi;
		Li:按旅客订票要求找到A[j];
		P(s[j]);
		Xi = A[j];
		if(Xi >= 1){
			Xi = Xi - 1;
			A[j] = Xi;
			V(s[j]);
			输出一张票；
		}else{
			V(s[j]);                //P操作与V操作在执行路径上一一匹配
			输出票已售完；
		}
		goto Li;
	}
coend	
~~~



### 6.7 PV操作与进程同步

#### 6.7.1 问题的提出

进程同步：并发进程为完成共同任务基于某个条件来协调执行先后关系而产生的协作制约关系

一个进程的执行等待来自于其他进程的消息

解决的基本思路：

​	定义一个信号量：其数值代表可用消息数

​	接收消息进程：执行P，无消息则等待

​	发出消息进程：执行V，有等待进程则释放



#### 6.7.2 1生产者 1消费者 1缓冲区问题

生产者和消费者共享缓冲区

缓冲区有空位时，生产者可放入产品，否则等待

缓冲区有产品时，消费者可取出产品，否则等待

![](D:\项目\markdown\操作系统\1生产者1消费者1缓冲区.png)

##### 程序框架：

![](D:\项目\markdown\操作系统\程序框架.png)

![](D:\项目\markdown\操作系统\同步关系.png)

信号量仅仅解决信号传递，数据传送需要共享缓冲区

##### 解决思路

同步关系1：

​	消费者一开始在等待产品到来，考虑设置一个信号量（等待产品）；

​	一开始无产品，初值为0

同步关系2：

​	生产者则在等待缓冲区中有空位，也可设置一个信号量（等待缓冲区）；

​	一开始缓冲区有空位，初值为1

##### 解决过程

~~~c
int B;                //共享缓冲区
Semaphore sput;       //可以使用的空缓冲区数
Semaphore sget;       //缓冲区内可以使用的产品数
sput = 1;             //缓冲区内允许放入一件产品
sget = 0;             //缓冲区内没有产品
~~~

![](D:\项目\markdown\操作系统\PV解决生产者消费者.png)



### 6.8 生产者消费者问题探究

![](D:\项目\markdown\操作系统\生产者消费者排列组合.png)



#### 6.8.1 PV解决1生产者1消费者1缓冲区问题

如6.7.2



#### 6.8.2 PV解决1生产者1消费者N缓冲区问题

~~~c
int B[k];                //共享缓冲区队列
Semaphore sput;         //可以使用的空缓冲区数
Semaphore sget;         //缓冲区内可以使用的产品数
sput = k;               //缓冲区内允许放入K件产品
sget = 0;               //缓冲区内没有产品
int putstr,getstr;      //循环队列指针
putptr = 0; getptr = 0;
~~~

![](D:\项目\markdown\操作系统\1生产者1消费者N缓冲区.png)

只有缓冲区是共享变量



#### 6.8.3 PV解决N生产者N消费者N缓冲区问题

~~~c
int B[k];                	 //共享缓冲区队列
Semaphore sput;         	 //可以使用的空缓冲区数
Semaphore sget;         	 //缓冲区内可以使用的产品数
sput = k;               	 //缓冲区内允许放入K件产品
sget = 0;               	 //缓冲区内没有产品
int putstr = 0,getstr = 0;   //循环队列指针
s1,s2:semaphore;             //多个生产者使用putptr,多个消费者使用getptr
s1 = 1; s2 = 1;
~~~

![](D:\项目\markdown\操作系统\N生产者N消费者N缓冲区.png)

多个生产者共享putptr,多个消费者共享getptr;

s1控制putptr,s2控制getptr



### 6.9 苹果橘子问题

![](D:\项目\markdown\操作系统\苹果橘子问题.png)

同步关系1：有苹果

同步关系2：有橘子

同步关系3：有空位

~~~c
int plate;
Semaphore sp;    //盘子里可以放几个水果
Semaphore sg1;   //盘子里有桔子
Semapore  sg2;   //盘子里有苹果
sp = 1;          //盘子里允许放入一个水果
sg1 = 0;         //盘子里没有桔子
sg2 = 0;         //盘子里没有苹果
~~~

![](D:\项目\markdown\操作系统\PV解决苹果橘子问题.png)



### 6.10 管程

#### 6.10.1 管程概念

![](D:\项目\markdown\操作系统\管程概念.png)



#### 6.10.2 管程的基本形式

~~~pascal
TYPE<管程名> = MONITOR
//①
define<(能被其他模块引用的) 过程名列表>;
use<(要引用的模块外定义的) 过程名列表>;

//②
procedure<过程名>（<形式参数表>);
  begin
    <过程体>;
  end;
  ......
procedure<过程名>（<形式参数表>);
  begin
    <过程体>;
  end;
//③
  begin
    <管程的局部数据初始化语句>;
  end;
~~~



#### 6.10.3 管程的条件变量

**条件变量**：当调用管程过程的进程无法运行时，用于阻塞进程的信号量

**同步原语**wait：当一个管程过程发现无法继续时（如发现没有可用资源时），它在某些条件变量上执行wait，这个动作引起调用进程阻塞

**同步原语signal:**用于释放在条件变量上阻塞的进程



#### 6.10.4 管程的执行

![](D:\项目\markdown\操作系统\管程的执行模型.png)

​	紫色里的优先级高于红色的

##### 管程过程执行中signal的处理问题

当使用signal释放一个等待进程时，可能出现两个进程同时停留在管程内。解决办法：

​	执行signal的进程等待，直到被释放进程退出管程或等待另一个条件

​	被释放进程等待，直到signal的进程退出管程或等待另一个条件

​		霍尔采用了第一种办法



#### 6.10.5 霍尔管程

##### 实现方法

使用signal释放一个等待进程时，霍尔管程让执行signal的进程等待，直到被释放进程退出管程或等待另一个条件

霍尔管程基于PV操作原语实现

​	Wait和signal可以是程序过程

​	可以用语言机制实现霍尔管程



##### 互斥调用霍尔管程的信号量

~~~~pascal
TYPE interf = RECORD
  mutex:semaphore    //调用管程过程前使用的互斥信号量
  next:semaphore     //发出signal的进程挂起自己的信号量
  next_count:integer //在next上等待的进程数
 END;
~~~~



##### 互斥调用霍尔管程的框架

~~~pascal
P(IM.mutex);
  <过程体>;
IF IM.next_count > 0 then V(IM.next);   //有高优先级的，先释放高优先级的，再释放自己
ELSE V(IM,mutex);
~~~



##### 霍尔管程的条件变量

~~~pascal
x_sem:semaphore;   //与资源相关的信号量
x_count:integer;   //在x_sem上等待的进程数
~~~



##### 霍尔管程的wait过程

~~~pascal
procedure wait(var x_sem : semaphore,var x_count:integer,var IM:interf);
begin
  x_count:= x_count + 1;
  if IM.next_count > 0 then V(IM.next);   
  						else V(IM.mutex);
P(x_sem);
x_count := x_count - 1;
end;
~~~



##### 霍尔管程的signal过程

~~~pascal
procedure signal(var x_sem:semaphore,var x_count:integer, var IM:interf);
begin
  if x_count > 0 then begin
  IM.next_count := IM.next_count + 1;    //先释放别人，再挂自己
  V(x_sem); 
  P(IM.next);                    //进入等待调用管程的队列
  IM.next_count := IM.next_count - 1;
 end;
end; 
~~~



#### 6.10.6 霍尔管程的例

##### 哲学家问题

![](D:\项目\markdown\操作系统\哲学家问题.png)

~~~pascal
TYPE dining_philosophers = MONITOR
  var state:array[0..4] of(thinking,hungry,eating);  //哲学家三个状态，思考、饥饿、吃
  	s:array[0..4] of semophore;                //定义5个条件变量，每个哲学家一个盘子
  	s_count : array[0..4] of integer;
  define pickup,putdown
  use wait,signal;
 procedure test(k :0..4){
 	if state[(k - 1) mod 5] <> eating and state[k] = hungry   //如果左手没吃，右手没吃，自己饿，就可以吃
 		and state[(k+1) mod 5] <> eating then
 			{state[k] := eating;                              //状态改为吃
 			 signal(s[k],s_count[k],IM);}						
 }
~~~

pickup 吃

~~~pascal
procedure pickup(i:0..4){
	state[i] := hungry; //饿了
	test(i);            //测试能不能吃
	if state[i] <> eating //测试结果不能吃，则等待
	then wait(s[i],s_count[i],IM);
}
~~~

putdown 放

~~~pascal
procedure putdown(i:0..4){
	state[i] := thinking;   //吃完去思考
	test((i - 1) mod 5);    //看看左手等没等待
	test((i + 1) mod 5);    //看看右手等没等待
}
~~~

~~~pascal
begin for i := 0 to 4 do state[i] := thinking; end;
~~~





~~~pascal
Cobegin
	process phiolosopher_i(){
		L:thingking();
		P(IM.mutex);
		dining_philosophers.pickup(i);
		IF IM.next_count > 0 then V(IM.next);
		ELSE V(IM.mutex);
		eating();
		P(IM.mutex);
		dining_phiolosophers.putdown(i);
		IF IM.next_count > 0 then V(IM.next);
		goto L;
	}
Coend	
~~~



##### 读者写者问题

![](D:\项目\markdown\操作系统\读者写者问题.png)

1.等待读的进程与计数；等待写的进程与计数

2.正在读的进程计数；正在与等待写的进程计数



~~~pascal
TYPE read-writer = MONITOR
	var Rc,Wc : integer；     //读，写
	var R, W  : semaphore；   //正在读，正在写
	var rc,wc : intege；r     //正在等待读，正在等待写
	define start_read, end_read, start_writer, end_writer;
	use wait, signal, check, release;
~~~

~~~pascal
begin 
	rc:=0; wc:=0; Rc:=0; Wc:=0; R:=0; W:=0; 
end;
~~~

开始读

~~~pascal
procedure start_read;
begin
	if wc>0 then wait(R,Rc,IM); //有人在等待写，等待
	rc := rc + 1;               //否则 读+1
	signal(R,Rc,IM);            //连续释放读者
end;
~~~

结束读

~~~pascal
procedure end_read;
begin
	rc := rc - 1;            //读完了，减一
	signal(W,Wc,IM);         //没人读了，释放等待写者
end;
~~~

开始写

~~~pascal
procedure start_write;
begin
	wc := wc + 1;            //写+1
	if rc > 0 or wc > 1 then wait(W,Wc,IM)//如果有人读或者有人在写，我就不能写
	
end
~~~

结束写

~~~pascal
procedure end_write;
begin
	wc := wc - 1;                    //写-1 
	if(wc > 0) then signal(W,Wc,IM);  //如果还有写者释放写者
			   else signal(R,Rc,IM);  //如果没有写者释放读者
end;
~~~



### 6.11 进程通信

#### 6.11.1 概念

交往进程通过**信号量操作**实现进程互斥和同步，这是一种低级通信方式

进程有时还需要交换更多的信息（如把数据传送给另一个进程），可以引进高级通信方式——**进程通信机制**，实现进程间用**信件**来交换信息

进程通信扩充了并发进程的数据共享



#### 6.11.2 进程直接通信

发送或接收信件的进程指出信件发给谁或从谁那里接收信件

​	send(P,信件)：把信件发送给进程P

​	receive(Q,信件)：从进程Q接收信件



#### 6.11.3 间接通信

发送或者接收信件通过一个信箱来进行，该信箱有唯一标识符

多个进程共享一个信箱

​	send(A,信件)：把信件传送到信箱A

​	receive(A,信件)：从信箱A接收信件



##### 信箱

是存放信件的存储区域，每个信箱可以分成信箱特征和信箱体两部分

​	信箱特征指出信箱容量、信件格式、指针等

​	信箱体用来存放信件，信箱体分成若干个区，每个区可容纳一封信



##### 原语

**发送信件**

​	若指定的信箱未满

​	则把信件送入信箱中指针所指示的位置，释放等待该信箱中信件的等待者

​	否则，发送信件者被置成等待信箱的状态

**接收信件**

​	若指定信箱中有信件

​	则取出一封信件，释放等待信箱的等待者

​	否则，接收信件者被置成等待信箱中信件的状态



### 6.12 高级进程的通信

#### 6.12.1 基于流的进程通信

多个进程使用一个共享的消息缓冲区（可称为管道、多路转接器、套接字）

一些进程往消息缓冲区中写入字符流（send/write)

一些进程往消息缓冲区中读出字符流(receive/read)



#### 6.12.2 基于字符流的进程通信规约

![](D:\项目\markdown\操作系统\基于字符流的进程通信规约.png)



#### 6.12.3 远程过程调用RPC

采用**客户/服务器**计算模式

**服务器进程**提供一系列**过程/服务**，供客户进程调用

**客户进程**通过调用服务器进程提供的**过程/服务**获得服务



考虑到客户计算机和服务器计算机的硬件异构型，外部数据表示XDR被引入来转换每台计算机的特殊数据格式为标准数据格式

##### 基于RPC/XDR的高级通信规约

![](D:\项目\markdown\操作系统\基于RPCXDR的高级通信规约.png)

参数翻译：先翻译成中间格式，然后翻译成服务器格式，再翻译成客户机格式



### 6.13 死锁

#### 6.13.1 产生

允许多个进程并发执行共享系统资源时，系统必须提供同步机制和进程通信机制

然而，对这种机制使用不当的话，可能会出现进程永远被阻塞的现象

例如，两个进程等待对方占有的一个资源，于是两者都不能执行而处于永远等待，这种现象称为“死锁”



##### 例子：

![](D:\项目\markdown\操作系统\死锁的产生例1.png)

![](D:\项目\markdown\操作系统\死锁的产生例2.png)

![](D:\项目\markdown\操作系统\死锁的产生例3.png)



#### 6.13.2 定义

一组进程处于死锁状态是指：每一个进程都在等待被另一个进程所占有的、不能抢占的资源

例如：

​	存在n个进程P1,P2,...Pn

​	进程Pi因为申请不到资源Ri而处于等待状态

​	而Ri又被Pi+1占有，Rn被P1占有

​	显然，这n个进程的等待状态永远不能结束，这n个进程就处于死锁状态



#### 6.13.3 解决死锁问题的三个方法

产生死锁的因素不仅与系统拥有的资源数量有关，而且与资源分配策略，进程对资源的使用要求以及并发进程的推进顺序有关

可以从三个方面来解决死锁问题

​	**死锁防止**

​	**死锁避免**

​	**死锁检测和恢复**



#### 6.13.4 死锁防止

##### 四个必要条件

1.互斥：至少有一个资源一次只能供一个进程使用，其他进程想使用必须等到其被释放为止。

2.不可剥夺：进程持有的资源只能被进程自己释放。

3.占有并等待：一个进程占有至少一个资源并想得到另一个资源，这另一个资源又被其他进程所占有。

4.循环等待： 有一组等待进程{P0,P1,...,Pn}，P0等待的资源为P1占有，P1等待的资源为P2占有,...,Pn-1等待的资源为Pn占有，Pn等待的资源为P0占有。形成一个等待环。



注意：所有四个条件必须同时成立才会出现死锁。虚幻等待条件意味着占有并等待条件，四个条件并不完全独立）



##### 破坏四个必要条件之一

**破坏互斥**（几乎不可能）

​	把独占性资源改造成共享性资源，使资源可同时访问而不是互斥使用。但对许多资源往往是不能做到的

**破坏不可剥夺**

​	采用剥夺式调度方法破环不可抢占，但剥夺式调度方法目前只适用于对主存资源和处理器资源的分配，而不适用于所有资源



##### 静态分配（预分配）

所谓静态分配是指一个进程必须在执行前就申请它所要的全部资源，并且直到它所要的资源都得到满足之后才开始执行

所有并发执行的进程要求的资源总和不超过系统拥有的资源数

采用静态分配后，进程在执行中不再申请资源，因而不会出现占有了某些资源再等待另一些资源的情况，**破环了占有并等待**



##### 层次分配

这种分配策略将**破环循环等待**

在层次分配策略下，资源分成多个层次

一个进程得到某一层的一个资源后，它只能再申请在较高层的资源

当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源

当一个进程获得了某一层的一个资源后，它想再申请该层中的另一个资源，那么，必须先释放该层中的已占资源

**（一个等待一个更高层次的，可能形成链，但是链尾不可能等待最低层次的，形成环）**



#### 6.13.5 死锁避免

当不能防止死锁的产生时，如果能掌握并发进程中与每个进程有关的资源申请情况，仍然可以避免死锁的发生

只需在为申请者分配资源前测试系统状态，若把资源分配给申请者会产生死锁的话，则拒绝分配，否则接收申请，为它分配资源



##### 银行家算法

借钱给有偿还能力的客户

​	系统首先检查申请者对资源的最大需求量，如果现存的资源可以满足它的最大需求量时，就满足当前的申请

​	换言之，仅仅在申请者可能无条件地归还它所申请的全部资源时，才分配资源给它



##### 银行家算法例子

为了进一步说明这种算法，考虑下面的例子

​	假设系统有三个进程P,Q,R，系统只有一类资源共10个，目前分配情况如下：

| 进程 | 已占资源 | 还需要申请数 |
| :--: | :------: | :----------: |
|  P   |    4     |      4       |
|  Q   |    2     |      2       |
|  R   |    2     |      7       |

Q已占4+2+2 = 8个，还剩10-8=2个。

Q借：先给Q，Q还的话还4个；然后给P，P还的话还8个；然后给R

P借，R借

![](D:\项目\markdown\操作系统\银行家算法例子.png)



#### 6.13.6 死锁检测

解决死锁问题的另一条路径是死锁检测方法

这种方法对资源的分配不加限制，但系统定时运行一个“死锁检测”程序，判断系统内是否已出现死锁，若检测到死锁则设法加以解除



##### 等待资源表与占用资源表

设置两张表格来记录进程使用资源的情况

**等待资源表**记录每个被阻塞进程等待的资源

**占用资源表**记录每个进程占有的资源

进程申请资源时，先查该资源是否为其它进程所占用；若资源空闲，则把该资源分配给申请者且登入占用资源表；否则，则登入进程等待资源表

![](D:\项目\markdown\操作系统\死锁的检测.png)

死锁检测程序时检测这两张表，若有进程Pi等待资源rk，且rk被进程Pj占用，则说Pi和Pj具有“等待占用关系”，记为W(Pi,Pj)

死锁检测程序反复检测这两张表，可以列出所有的“等待占用关系”

如果出现W(Pi,Pj),W(Pj,Pk),......,W(Pm,Pn),W(Pn,Pi)时，显然，系统中存在一组循环等待资源的进程，Pi,Pj,Pk,......Pm,Pn,也就是说出现了死锁



##### 死锁检测的数据结构

把两张表格中记录的进程使用和等待资源的使用情况用一个矩阵A来表示

![](D:\项目\markdown\操作系统\死锁检测的数据结构.png)



##### 死锁检测的算法

可用传递闭包算法检测是否有死锁产生，即对 矩阵A构造传递闭包A*【bij】

A*【bij】中的每个bij是对A【bij】执行如下算法：

~~~pascal
for k:=1 to n do
  for i:= i to n do
    for j:=i to do
      bij:=bij ∨ (bik ∧ bkj)
~~~

AxA 长度2 闭环，AxAxA 长度3 闭环，A的n次闭包长度n闭环

闭环出现，对角线为1



##### 死锁检测后的解决办法

可采用重新启动进程执行的办法，恢复工作应包含重启动一个或全部进程，以及从哪一点开始重启动

全部卷入死锁从头开始启动，但这样的代价相当大

在进程执行过程中定时设置校验点，从校验点开始重执行

中止一个卷入死锁的进程，以后重执行







### 5.4 例题

某系统有n台互斥使用的同类设备，3个并发进程需要3，4，5台设备，可确保系统不发生死锁的设备数n最小（）

答案：10.

解析：3个进程需要的最大情况为2，3，4，此时再多一个资源就可以打破死锁的环境，2+3+4+1=10.








