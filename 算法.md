# 算法

## 1. 常用数据结构和技巧

### 1.1 数组、字符串

优点

​	构建一个数组非常简单

​	能让我们在O（1）的时间里根据数组的下标（index)查询某个元素

缺点

​	构建时必须分配一段连续的空间

​	查询某个元素时，耗费O（n）

​	删除和添加某个元素，耗费O(n)



### 1.2 链表

优点：

​	灵活地分配内存空间

​	能在O（1）时间内删除或添加元素

缺点：

​	查询元素需要O（n)时间

解题技巧：

​	利用快慢指针，构建一个虚假的链表头

如何训练该技巧？

​	在纸上或者白板上画出节点之间的相互关系，画出修改的方法

#### 1.2.1 单链表

链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起



#### 1.2.2 双链表

与单链表不同的是，双链表的每个结点中都含有两个引用字段



### 1.3 栈

特点：

​	后进先出

算法基本思想

​	可以用一个单链表来实现

​	只关心上一次的操作

​	处理完上一次的操作后，能在O（1）时间内查找到更前一次的操作

​	

### 1.4 队列

特点：

​	先进先出

常用的场景

​	广度优先搜索

#### 1.4.1 双端队列

基本实现：

​	可以利用一个双链表

​	队列的头尾两端在O（1）的时间内进行数据的查看、添加和删除

常用场景

​	实现一个长度动态变化的窗口或者连续区间



### 1.5 树

树的共性

**结构直观**

**通过树问题来考察 递归算法 掌握的熟练程度**



**面试中常考的树的形状有**

普通二叉树

平衡二叉树

完全二叉树

二叉搜索树

四叉树

多叉树

特殊的树：红黑树、自平衡二叉搜索树





**遍历**

前序遍历

中序遍历

后序遍历



#### 1.5.1 红黑树

是一颗BST树

节点是红色或黑色

根是黑色，所有叶子都是黑色

每个红色节点必须有两个黑色的子节点

从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点

**任一节点其中子树的高度，最多是另一个节点子树高度的二倍**



##### 插入

插入前所有结点都为红

1.当前节点是根节点，把根节点改为黑色

2.当前节点的父节点是黑节点：保持不变

3.当前节点的父节点是红节点，并且当前节点的叔节点是红节点，把父节点和叔节点改为黑色，把祖父节点改为红色，把祖父节点作为当前节点，向上判断

4.当前节点的父节点是红节点，并且当前节点的叔节点不是红节点：旋转后，当前节点改为黑色，祖父节点改为红色



## 2. 高级数据结构

### 2.1 优先队列

#### 与普通队列的区别

保证每次取出的元素是队列中优先级最高的

优先级别可自定义



#### 最常用的场景

从杂乱无章的数据中按照一定的顺序（或优先级）筛选数据



#### 本质

二叉堆的结构，堆在英文里叫Binary Heap

利用一个数据结构来实现完全二叉树



#### 特性

数组里的第一个元素array[0]拥有最高的优先级给定一个下标i，那么对于元素array[i]而言

**父结点**对应的元素下标是**（i- 1）/2**

**左侧子节**点对应的元素下标是**2 * i +1**

**右侧子节点**对应的元素下标是**2 * i + 2**

数组中每个元素的优先级都必须高于它两则子节点



#### 基本操作

向上筛选（o(logk)：新加元素

向下筛选(o(logk))：删除元素



初始化（o(n)）



~~~java
PriorityQueue<Map.Entry<Integer,Integer>> maxheap = new PriorityQueue<>((a,b) -> b.getValue() - a.getValue()); //大顶堆
~~~

~~~java
PriorityQueue<Map.Entry<Integer,Integer>> minheap = new PriorityQueue<>();  //小顶堆
~~~



#### 例题

Leetcode 347



### 2.2 图

#### 最基本知识点

阶、度

树、森林、环

有向图、无向图、完全有向图、完全无向图

连通图、连通分量

图的存储和表达方式：邻接矩阵、邻接链表



#### 围绕图的算法

图的遍历：深度优先、广度优先

环的检测：有向图、无向图

拓扑排序

最短路径算法：Dijikstra、Ford、Floyd Warsh

连通性相关算法：Kosaraju、Tarjan、求解孤岛的数量、判断是否为树

图的着色、旅行商问题



#### 必须熟练掌握

图的存储和表达方式：邻接矩阵、邻接链表

图的遍历：深度优先、广度优先

二部图的检测、树的检测、环的检测：有向图：无向图

拓扑排序

联合查找算法

最短路径：Dijikstra、Ford



#### 例题

Leetcode 785



### 2.3 前缀树

也称字典树，这种数据结构被广泛地运用在字典查找当中



#### 字典查找

例如：给定一系列构成字典的字符串，要求在字典当中找出所有以“ABC”开头的字符串

##### 暴力搜索法

时间复杂度O（M*N）

##### 前缀树

时间复杂度：O（M）



#### 经典应用

搜索框输入搜索文字，会罗列以搜索词开头的相关搜索

汉语拼音输入法



#### 重要性质

每个结点至少包含两个基本属性

children:数组或者集合，罗列出每个分支当中包含的所有字符

isEnd：布尔值，表示该节点是否为某字符串的结尾

根节点是空的，除了根节点，其他所有节点都可能是单词的结尾，叶子结点一定都是单词的结尾



#### 最基本的操作

##### 创建

遍历一遍输入的字符串，对每个字符串的字符进行遍历

从前缀树的根节点开始，将每个字符加入到节点的children字符集当中

如果字符集已经包含了这个字符，跳过

如果当前字符是字符串的最后一个，把当前节点的isEnd标记为真



##### 搜索

从根节点出发，逐个匹配输入的前缀字符

如果遇到了，继续往下一层搜索

如果没遇到，则结束



#### 例题

力扣 208 212



### 2.4 线段树

#### 先从一个例题出发

假设我们有一个数组array[0...n-1]，里面有n个元素，现在我们要经常对这个数组做两件事：

1.更新数组元素的数值

2.求数组任意一段区间里元素的总和（或者平均值)

##### 方法一：遍历一遍数组

时间复杂度：O（n)

##### 方法二：线段树

时间复杂度：O（logn）



#### 什么是线段树

一种按照二叉树的形式存储数据的结构，每个结点保存的都是数组里某一段的总和



#### 例题：

力扣 315



### 2.5 树状数组

binary indexed tree

#### 先从一个例题出发

假设我们有一个数组array[0,...n-1]，里面有n个元素，现在我们要经常对这个数组做两件事：

1.更新数组元素的数值

2.求数组前k个元素的总和（或者平均值）

##### 方法一：线段树

时间复杂度：O(logn)

##### 方法二：树状数组

时间复杂度：O(logn)



#### 重要的基本特征

利用数组来表示多叉树的结构，和优先队列有些类似

优先队列是用数组来表示完全二叉树，而树状数组是多叉树

树状数组第一个元素是空节点

如果节点tree[y]是tree[x]的父结点，那么需要满足y = x - (x & (-x))



#### 例题：

力扣308



## 3. 排序

基本的排序算法：【简单直接迅速写出没有bug的代码】

​	冒泡排序

​	插入排序

常考的排序算法：【解决绝大部分涉及排序问题的关键】

​	归并排序

​	快速排序

​	拓扑排序

其他排序算法：【掌握好它的解题思想能开阔解题思路】

​	堆排序

​	桶排序



### 3.1 冒泡排序

稳定的排序

~~~java
void Bubblesort(int []nums){
	boolean hasChange = true;
	for(int i = 0; i < nums.length - 1 && hasChange; i++){
		hasChange = false;
		for(int j = 0; j < nums.length - i - 1){
			if(nums[j] > nums[j + 1]){
				swap(nums,j,j + 1);
				hasChange = true;
			}
		}
	}
}

void swap(int nums[],int i, int j){
	int temp = nums[i];
	nums[i] = nums[j];
	nums[j] = temp;
}
~~~



#### 算法分析

**空间复杂度：O(1)**

在排序的过程中，直接在给定的数组里进行元素的两两交换

**时间复杂度：O（n²）**

情景一：给定的数组按照顺序已经排好

只需进行n-1次的比较，两两交换次数为0，时间复杂度是O(n)，这是最好的情况。

情景二：给定的数组按照逆序排列

需要进行n(n-1)/2次比较，时间复杂度是O(n²)，这是最坏的情况

情景三：给定的数组杂乱无章

在这种情况下，平均时间复杂度是O(n²)。



### 3.2 插入排序

稳定的排序算法

#### 与冒泡排序对比

在冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的

在插入排序中，经过每一轮的排序处理后，数组前端的数都是排好序的



#### 算法思想

不断地将尚未排好序的数插入到已经排好序的部分



~~~java
void Insertsort(int[] nums){
	for(int i = 1, j,current; i < nums.length; i++){
		current = nums[i];
		for(j = i - 1;j >= 0 && nums[j] > current; j--)
			nums[j + 1] = nums[j];
        
		nums[j + 1] = current;
	}
}
~~~



#### 算法分析

**空间复杂度：O(1)**

在排序的过程中，直接在给定的数组里进行元素的两两交换



**时间复杂度：O（n²）**

情景一：给定的数组按照顺序已经排好

只需进行n-1次的比较，两两交换次数为0，时间复杂度是O(n)，这是最好的情况。

情景二：给定的数组按照逆序排列

需要进行n(n-1)/2次比较，时间复杂度是O(n²)，这是最坏的情况

情景三：给定的数组杂乱无章

在这种情况下，平均时间复杂度是O(n²)。



#### 例题

力扣147



### 3.3 归并排序

#### 分治的思想

归并排序的核心思想是分治，把一个复杂问题拆分成若干个子问题来求解



#### 算法思想

把数组从中间划分成两个子数组

一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素；

依次按照递归的返回顺序，不断地合并排好序的数组，直到最后把整个数组的顺序排好



~~~java
void sort(int A[],int lo, int hi){
	if(lo >= hi)
		return;
	
	int mid = lo + (hi - lo) /2 ;
	sort(A,lo,mid);
	sort(A,mid + 1,hi);
	merge(A,lo,mid,hi);
}
~~~

~~~java
void merge(int []nums,int lo, int mid, int hi){
	int []copy = nums.clone();
    
	int k = lo, i = lo, j = mid + 1;
    
	while(k <= hi){
		if(i > mid){       //左半边处理完毕，只剩下右半边的数
			nums[k++] = copy[j++];
		}else if(j > hi){  //右半边处理完毕，只剩下左半边的数
			nums[k++] = copy[i++];
		}else if(copy[j] < copy[i]){  //右边的数小于左边的数
			nums[k++] = copy[j++];
		}else{                        //左边的树小于右边的数
			nums[k++] = copy[i++];    
		}
	}
}
~~~



#### 算法分析

**时间复杂度：O(nlogn)**

归并算法是一个不断递归的过程，假设数组的元素个数是n。

一共要进行log(n)层的大小切分；

每一层的合并复杂度都是O(n);

所以整体的复杂度就是O(nlogn);



**空间复杂度：O(n)**

由于合并n个元素需要分配一个大小为n的额外数组，合并完成之后，这个数组就会被释放掉



### 3.4 快速排序

#### 算法思想

快速排序也采用了分治的思想：

把原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组；

在分成较小和较大的两个子数组中，如何确定一个基值十分关键



~~~java
void sort(int []nums,int lo, int hi){
	if(lo >= hi)
		return;
	int p = partition(nums,lo,hi);
	
	sort(nums,lo,p - 1);
	sort(nums,p+1,hi);
}
~~~

~~~java
int partiton(int[] nums, int lo, int hi){
	swap(nums,randRange(lo,hi),hi);
	int i,j;
	for(i = lo,j = lo; j < hi;j++){
		if(nums[j] <= nums[hi])
			swap(nums,i++,j);
	}
	swap(nums,i,j);
	return i;
}
~~~



#### 算法分析

**时间复杂度O（nlogn)**

最优情况下，基准值为子数组的中间数

最坏情况下，每次选择基值的时候，都不幸选择了数组里的最大或最小值；其中一个子数组的长度为1，另一个长度只比父数组少1.



**空间复杂度O(logn)**

和归并排序不同，快速排序在每次递归的过程中；

只需要开辟O(1)的存储空间来完成交换操作实现直接对数组的修改；

而递归次数为logn，所以它的整体空间复杂度完全取决于压堆栈的次数



#### 例题

力扣215



### 3.5 拓扑排序

#### 应用场合

拓扑排序就是要将图论里的顶点按照相连的性质进行排序



#### 前提

必须是有向图

图里面没有环



~~~java
void sort(){
	Queue<Integer> q = new LinkedList();
	for(int v = 0; v < V; v++)
		if(indegree[v] == 0)
			q.add(v);
	while(!q.isEmpty()){
		int v = q.poll();
		print(v);
		
		for(int u = 0; u < adj[v].length;u++){
			if(--indegree[u] == 0)
				q.add(u);
		}
	}
}
~~~



#### 算法分析

时间复杂度：O(n)

空间复杂度：O(n)





| 排序法 | 平均时间 | 最差情形    | 稳定度 | 额外空间 | 备注                          |
| ------ | -------- | ----------- | ------ | -------- | ----------------------------- |
| 冒泡   | O(n2)    | O(n2)       | 稳定   | O(1)     | n小时较好                     |
| 选择   | O(n2)    | O(n2)       | 不稳定 | O(1)     | n小时较好                     |
| 插入   | O(n2)    | O(n2)       | 稳定   | O(1)     | 大部分已排序时较好            |
| 基数   | O(logRB) | O(logRB)    | 稳定   | O(n)     | B是真数(0-9)，R是基数(个十百) |
| Shell  | O(nlogn) | O(ns) 1<s<2 | 不稳定 | O(1)     | s是所选分组                   |
| 快速   | O(nlogn) | O(n2)       | 不稳定 | O(nlogn) | n大时较好                     |
| 归并   | O(nlogn) | O(nlogn)    | 稳定   | O(n)     | n大时较好                     |
| 堆     | O(nlogn) | O(nlogn)    | 不稳定 | O(1)     | n大时较好                     |

## 4. 递归与回溯

### 4.1 性质

#### 递归：函数调用本身

把大规模的问题不断地便变小，再进行推导的过程



#### 回溯：利用递归的性质

从问题的起始点出发，不断尝试

返回一步甚至多部再做选择，直到抵达终点的过程



### 4.2 递归

递归是一种调用自身函数的算法

特点：可以使一个看似复杂的问题变得简洁和易于理解



经典案例：汉诺塔

~~~c
void hano(char A,char B,char C,int n){
	if(n > 0){
		hano(A,C,B,n -1);
		print(A + "->" + C);
		hano(B,A,C,n -1);
	}
}
~~~



#### 算法思想

要懂得如何将一个问题得规模变小

再利用从小规模问题中得出的结果

结合当前的值或者情况，得出最终的结果



#### 通俗理解

（自顶向下）

把要实现的递归函数，看成已经实现好的

直接利用解决一些子问题

思考：如何根据子问题的解以及当前面对的情况得出答案



#### 递归写法结构

~~~c
function fn(n){
	//第一步：判断输入或者状态是否非法？
	if(input / state is invalid){
		return;
	}
	
	//第二步：判断递归是否应当结束？
	if(match condition){
		return some value;
	}
	
	//第三步：缩小问题规模
	result1 = fn(n1);
	result2 = fn(n2);
	...
	
	//第四步：整合结束
	return combine(result1,result2)
	
}
~~~



#### 时间复杂度分析

##### 迭代法



##### 公式法

当递归函数的执行函数满足如下的关系式时，可以利用公式法：

​	T(n) = a · T(n/b) + f(n)  f(n)指每次递归完毕后，额外的计算执行时间

当参数a,b都确定时，只看递归部分，时间复杂度就是O（n的log(b)a次方)



需要牢记的三种情况

###### 情况一

当递归部分的执行时间O（n的log(b)a次方) >f(n)的时候，最终的时间复杂度就是O（n的log(b)a次方)

###### 情况二

当递归部分的执行时间O（n的log(b)a次方) < f(n)的时候，最终的时间复杂度就是f(n)

###### 情况三

当递归部分的执行时间O（n的log(b)a次方) = f(n)的时候，最终的时间复杂度就是O（n的log(b)a次方)logn



#### 例题：

力扣91,247



### 4.3 回溯

回溯算法是一种试探算法，与暴力搜索最大的区别：

在回溯算法中，是一步步向前试探，对每一步探测的情况评估，再决定是否继续，可避免走弯路



回溯算法的精华

出现非法的情况时，可退到之前的情景，可返回一步或多步

再去尝试别的路径和办法

想要采用回溯算法，就必须保证：每次都有多种尝试的可能



#### 回溯写法结构

~~~c
function fn(n){
	//第一步;判断输入或者状态是否非法？
	if(input/state is invalid){
		return;
	}
	
	//第二步：判断递归是否应应当结束
	if(march condition){
		return some value;
	}
	
	//遍历所有可能出现的情况
	for(all possible cases){
	//第三步：尝试下一步的可能性
		solution.push(case);
	
	//递归
		result = fn(m);
	
	//第四步：回溯到上一步
		solution.pop(case);
	}
}
~~~



#### 例题

力扣39，52



## 5.深度与广度优先搜索

### 5.1 DFS

DFS解决连通性的问题，即给定一个起始点（或某种起始状态）和一个终点（或某种最终状态），判断是否有一条路径能从起点连接到终点

很多情况下，联通的路径有很多条，只需找出一条即可，DFS只关心路径存在与否，不在乎其长短



#### 算法思想

从起点出发，选择一个可选方向不断向前，直到无法继续为止

然后尝试另外一种方向，直到最后走到终点



#### DFS递归实现

利用递归去实现DFS可以让代码看上去很简洁

递归地时候需要将当前程序中的变量以及状态压入到系统的栈里面

压入和弹出栈都需要较多的时间，如果需要压入很深的栈，会造成运行效率底下



#### DFS非递归实现

栈的数据结构也支持压入和弹出操作

完全可以利用栈来提高效率



#### 算法分析

由于DFS是图论里的算，分析利用DFS解题的复杂度时，应当借用图论的思想，图有两种表示方式：

##### 邻接表（图里有V个顶点，E条边）

访问所有顶点的时间为O(V),查找所有顶点的邻居的时间为O(E),所以总的时间按复杂度是O(V+E)

##### 邻接矩阵（图里有V个顶点，E条边）

查找每个顶点的邻居需要O(V)的时间，所以查找整个矩阵的时候需要O（V²)的时间



#### 利用DFS在迷宫里找一条路径

由于迷宫是用矩阵表示，所以假设它是一个M行N列邻接矩阵

时间复杂度为O（MxN）

因为一共有MxN个顶点，所以时间复杂度为O（MxN）

空间复杂度为O（MxN）

DFS需要堆栈来辅助，在最换坏情况下所有顶点都被压入堆栈，所以空间复杂度为O（MxN）



#### 如何用DFS搜索最短路径

##### 暴力解法

找出所有的路径，然后比较它们的长短，找出最短的那个

如果硬要使用DFS去找最短的路径，我们必须尝试所有的可能

DFS解决的只是连通性问题，不是用来求解最短路径问题的



##### 优化解题思路

一边寻找目的地，一边记录它和起始点的距离（也就是步数）

当发现从某个方向过来所需要的步数更少，则更新到这个点的步数

如果发现步数更多，则不再继续尝试



### 5.2 BFS

BFS一般用来解决最短路径的问题

从起点出发，一层一层地进行

每层当中的点距离起始点的步数都是相同的

借助的数据结构队列



#### 双端BFS

同时从起始点和终点开始进行的BFS称为双端BFS

双端BFS可以大大地提高搜索的效率

例如，想判断社交应用程序中两个人之间需要经过多少朋友介绍才能互相认识



#### 算法分析

##### 邻接表（图里有V个顶点，E条边）

时间复杂度O(V+E)

每个顶点都需要被访问一次，因此时间复杂度是O（V)，在访问每个顶点的时候，与它相连的顶点（也就是每条边）也都要被访问一次，所以加起来就是O(E),因此整体时间复杂度就是O(V+E)



##### 邻接矩阵（图里有V个顶点，E条边）

时间复杂度O（V²）

由于有V个顶点，每次都要检查每个顶点与其他顶点是否有联系，因此时间复杂度是O（V²）



#### 利用BFS在迷宫里找一条路径

由于迷宫是用矩阵表示，所以假设它是一个M行N列邻接矩阵

时间复杂度为O（MxN）

因为一共有MxN个顶点，所以时间复杂度为O（MxN）

空间复杂度为O（MxN）

DFS需要堆栈来辅助，在最换坏情况下所有顶点都进入队列一次，弹出一次，所以空间复杂度为O（MxN）



## 6.动态规划

### 6.1 定义

一种数学优化的方法，也是编程的方法



### 6.2 重要属性

最优子结构

​	-状态转移方程f(n)

重叠子问题



### 6.3例题：

#### 最长子序列的长度

力扣300

将问题规模减少，推导出状态转义方程式

f(n)表示数组nums[0,1,2,...,n-1]中最长的子序列

f(n-1)表示数组nums[0,1,2,...n-2]中最长的子序列

f(1)表示数组nums[0]的最长子序列

​	最后的数一定包含在f(n)中

##### 解决动态规划问题最难的两个地方：

如何定义f(n)

​	对于这道题而言，f(n)是以nums[n-1]结尾的最长的上升子序列的长度

如何通过f(1),f(2),f...f(n-1)推导出f(n)，即状态转移方程

​	拿nums[n-1]与比它小的每一个值nums[i]作比较，其中1≤i＜n，然后加1即可

​	因此状态转移方程为：

​		f(n) = max{f(i)} + 1 (1≤i<n-1，并且nums[i-1] < nums[n-1])



#### 递归解题

~~~java
class LISRecursion{
	static int max;
	
	public int f(int[] nums, int n){
		if(n <= 1){         //数组长度为0或1
			return n;
		}
		
		int result = 0, maxEndingHere = 1;
	   //maxEndingHere含义是包含当前最后一个元素的情况下，最长的上升子序列长度
        
        for(int i = 1; i < n;i++){  //从头遍历数组，递归求出以每个点为结尾的子数组中最长上升序列的长度
            
            result = f(nums,i);
	
			if(nums[i-1]<nums[n-1] && result + 1>maxEndingHere){
			//如果该数比目前最后一个数要小，就能构成一个新的上升子序列，这个新的子序列有可能成为最终的答案
                maxEndingHere = result + 1;
           //最后返回以当前数结尾的上升子序列的最长长度
			}
		}
		
		if(max < maxEndingHere){
			max = maxEndingHere;
		}
		return maxEndingHere;
	}
	
	public int LIS(int[] nums){s
		max = 1;
		f(nums,num.length);
		return max;
	}
	
}
~~~

时间复杂度O(2的n次方) 



#### 记忆化解题

~~~java
class LISMemorization{
	static int max;
	static HashMap<Integer,Integer> cache;  // 定义一个哈希表cache，用来保存我们的计算结果
	
	public int f(int[] nums, int n){
		if(cache.containsKey(n)){  //判断一下对这个输入，我们是否已经计算过了，也就是cache里面是否已经保留了这个值，是的话，立即返回，如果不是，再继续递归调用
			return cache.get(n);
		}
		
		if(n <= 1){
			return n;
		}
		
		int result = 0,maxEndingHere = 1;
		
		for(int i = 1; i < n; i++){
			//...
		}
		
		if(max < maxEndingHere){
			max = maxEndingHere
		}
		
		cache.put(n,maxEndingHere)
		return maxEndingHere;
	}
}
~~~

时间复杂度O（n²）

这种将问题规模不断减少的做法，我们把它成为自顶向下



#### 自底向上解题

~~~java
class LISDP{
	public int LIS(int []nums, int n){
		int[]cache = new int[n];
		int i,j,max = 0; 
		
		for(int i = 0; i < n; i++) //初始化cache里的每个元素的值为1
			cache[i] = 1;
		
		for(i = 0; i < n; i++){
			for(j = 0; j < i; j++){
                //拿遍历中遇到的每个元素nums[j]与nums[i]比较，如果发现nums[j] <nums[i],说明发现nums[i]有机会构成上升序列，如果新的上升序列比之前计算过的还要长，更新一下，保存到cache数组里
				if(nums[j] < nums[i] && cache[i] < cache[j] + 1)
					cache[i] = cache[j] + 1;
			}
			max = Math.max(max,cache[i]);
		}
		return max;
	}
}
~~~

时间复杂度O（n²）



### 6.4解题难点

应当采用什么样的数据结构来保存什么样的计算结果

如何利用保存下来的计算结果推导出状态转移方程



### 6.5 线性规划

各个子问题的规模以线性的方式分布

子问题的最佳状态或结果可以存储在一维线性的数据结构中，例如：一维数组，哈希表

通常我们会用dp[i]表示第i个位置的结果，或者从0开始到第i个位置为止的最佳状态或结果



#### 基本形式

**当前所求的值仅仅依赖于有限个先前计算好的值，即dp[i]仅仅依赖于有限个dp[j]，其中j<i**

例题1:

​	斐波那契数列:dp[i] = dp[i - 1] + dp[i - 2] 力扣70

例题2

​	给定一个数组，不能选择相邻的数，求如何才能使总数最大，力扣198

​	dp[i]，截止第i个点我们收获的最大的数

​	dp[i] = max{nums[i] + dp[i - 2] , do[i -1]}

~~~java
public int rob(int [] nums){
	int n = nums.length;
	
	if(n == 0) return 0;
	if(n == 1) return nums[0];
	
	int []dp = new int[n];
	
	dp[0] = nums[0];
	dp[1] = Math.max(nums[0],nums[1]);
	
	for(int i = 2; i < n; i++){
		dp[i] = Math.max(nums[i] + dp[i - 2], dp[i -1]);
	}
	
	return dp[n - 1];
}
~~~



例题3：

​	力扣62

 dp[i][j]  = dp[i - 1][j]  + dp[i][j - 1];



**当前所求的值仅仅依赖于所有先前计算和的值，即dp[i]是各个dp[j]的某种组合，其中j由0遍历到i -1** 

例题，求解最长上升子序列时，dp[i] = max{dp(i) + 1} + 1  0 ≤j<i



### 6.6 区间规划

各个子问题的规模有不同的区间来定义

子问题的最佳状态或结果可以存储在二维数组中

这类问题的时间复杂度一般为多项式时间，即对于一个大小为n的问题时，时间复杂度不会超过n的多项式倍数



例题：

最长回文子序列 力扣516

递归公式：当首尾的两个字符相等时，dp[0][n - 1] = dp[1][n - 2] + 2

​				  否则：dp[0][n - 1] = max{dp[1][n - 1] , dp[0][n - 2]}

~~~
public static int LPS(String s){
	int n = s.length();
	int [][] dp = new int[n][n];  //定义dp矩阵，dp[i][j]表示从字符串第i个字符到第j个字符之间的最长回文
	
	for(int i = 0; i < n; i++) dp[i][i] = 1; //将对角线元素设为1，即单个字符的回文长度为1
	
	for(int len = 2; len <= n; len++){//从长度2开始，尝试将区间扩大，一直扩大到n
		for(int i = 0; i < n -len + 1; i++){//在扩大的过程中，每次都得出区间的起始位置i和结束位置j
			int j = i + len - 1;
			
			if(s.charAt(i) == s.charAt(j)){//比较一下区间首尾的字符是否相等
				dp[i][j] = 2 + (len == 2 ? 0 : dp[i + 1][j - 1]);//如果相等，就加2
			}else{
				dp[i][j] = Math.max(dp[i + 1][j] , dp[i][j - 1]);//如果不等，从规模更小的字符串中得出最长的回文长度
			}
		}
	}
	return dp[0][n - 1];
}
~~~



### 6.7 约束规划

例题：0 - 1背包问题

给定n个物品，每个物品有各自的价值Vj和重量wi，在限定的最大重量W内，我们如何选择，才能使被带走的物品的价值总和最大？



#### 非决定性多项式

时间复杂度

​	程序运行的时间随着问题规模扩大的增长得有多快

非多项式级时间复杂度

​	指数级复杂度，如O（2的n次方）

​	全排列算法，复杂度为O（n!)

多项式级时间复杂度

​	O（1），O（n），O（n x log(n))， O（n²),O(n³)



## 7. 二分搜索与贪婪

### 7.1 二分搜索算法

看似简单，写对很难

变形很多

在面试中常用来考察code能力



#### 定义

也称折半搜索，是一种在有序数组中查找某一特定元素的搜索算法



#### 运用前提

数组必须是排好序的

输入并不一定是数组，也可能是给定一个区间的起始和终止的位置



#### 优点

O（logn) 是一种非常高效的搜索

#### 缺点

要求待查找的数组或区间是排好序的

​	若要求对数组进行动态地删除和插入操作并完成查找，平均复杂度会变成O（n）

​	采取自平衡的二叉查找树

​		可在O(nlogn)的时间内用给定的数据结构建出一棵二叉查找树

​		可在O(logn)的时间内对数据进行搜索

​		可在O(logn)的时间内完成删除和插入的操作



当：输入的数组或区间是有序的，且不会常变动，要求从中找出一个满足条件的元素--->采用二分搜索

~~~java
int binarySearch(int nums[], int target, int low, int high){
	if(low > high)   //如果起点大于终点，非法区间后者没有
		return -1;
	
	int middle = low + (high - low) /2 ;
	//不能简单地用(low + high) / 2，这样可能会导致溢出
	if(nums[middle] == target)
		return middle;
	
    //取左半边和右半边的区间时，middle已经确定不是我们要的，不必加入左右半边
	if(target < nums[middle]){
		return binarySearch(nums,target,low,middle - 1);
	}else{
		return binarySearch(nums,target,middle = 1, high);
	}
}
~~~

时间复杂度O(logn)



非递归写法

~~~java
int binarySearch(int []nums, int target, int low, int high){
	while(low <= high){
		int middle = low + (high - low) / 2;
		
		if(nums[middle] == target)
			return middle;
		
		if(target < nums[middle]){
			high = middle - 1;
		}else{
			low = middle + 1;
		}
	}
	
	return -1;
}
~~~



#### 二叉搜索的核心

确定搜索的范围和区间

取中间的数判断是否满足条件

如果不满足条件，判定应该往哪个半边继续搜索



#### 找确定的边界

边界分为上下边界，有时也称为左右边界

确定的边界，指边界的数值等于要找的目标数



##### 例题：

力扣34

第一个目标值为下边界，第二个目标值为上边界



#### 找模糊的边界

二分搜索可以用来查找一些模糊的边界

模糊的边界，即边界的值不等于目标的值，而是大于或小于目标的值



#### 旋转的数组

##### 例题

力扣33



#### 不定长的边界

有一段不知道具体长度的日志文件，里面记录了每次登陆的时间，已知日志是按顺序从头到尾记录的，没有记录日志的地方为空，那么，当前日志的长度是多少

##### 直观做法

顺序遍历这个数组，一直遍历下去

当发现第一个null的时候，我们就知道了日志的总数量了

##### 二分搜索做法

一开始设置low = 0, high = 1

只要logs[high]不为null,high * 2

当logs[high]为null的时候，可以在区间[0,high]进行普通的二分搜索了



### 7.2 贪婪算法

是一种比较直观的算法

难以证明正确性

#### 定义

贪婪是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法

#### 优点

对于一些问题，贪婪算法非常的直观有效

#### 缺点

往往，它得到的结果并不是正确的

贪婪算法容易过早地做出决定，从而没有办法达到最优解

不从整体的角度去考虑，仅对局部感兴趣



不能用贪婪算法解0-1背包问题



#### 例题：

力扣253 在给定一系列会议的起始时间和结束时间，求最少需要多少个会议室就可以让这些会议顺利召开

##### 最暴力的解法

把所有的会议组合找出来

从最长的组合开始检查，看看各个会议之间有没有冲突，直到发现一组会议没有冲突



##### 贪婪做法

会议都是按照他们的起始时间顺序进行的

要给新的就要开始的会议找会议室，先看当前有无空会议室

如果有则在空会议室开会，无则开设一个新的

~~~java
int minMeetingRooms(Interval[] intervals){
	if(intervals == null || intervals.length == 0)
		return 0;
	
	Arrays.sort(intervals,new Comparator<Interval>(){
		public int compare(Interval a, Interval b){return a.start - b.start;}
	})
	
	PriorityQueue<Interval> heap = new PriorityQueue<Interval>(intervals.length, new Comparator<Interval>(){
		public int compare(Interval a, Interval b){return a.start - b.start;}
	})
	
	heap.offer(intervals[0]);
	
	for(int i = 1; i < intervals.length; i++){
		Interval interval = heap.poll();
		if(intervals[i].start >= interval.end){
			interval.end = intervals[i].end;
		}else{
			heap.offer(intervals[i]);
		}
		heap.offer(interval)
	}
	return heap.size();
}
~~~

