

# 计算机网络

## 1.什么是Internet

### 1.1  组成细节

数以百万计的互联计算设备：主机=端系统；运行网络应用

通信链路：光纤，铜缆，无线电，卫星

分组交换，转发分组：路由器和交换机

### 1.2 服务

为网络应用提供通信服务的通信基础设施：WEB，EMAIL,网络游戏，社交网络

为网络应用提供应用编程接口（API)：支持应用程序发送接收数据;提供类似于邮政系统的数据传输服务



## 2. 什么是网络协议

### 2.1概念 

协议是计算机网络有序运行的重要保证，是为进行网络中的数据交换而建立的规则、标准或约定。

规定了所交换消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的“动作”

### 2.2 三要素

语法：数据与控制信息的结构或格式；信号电平

语义：需要发出何种控制信息；完成何种动作以及做出何种响应；差错控制

时序：时间顺序；速度匹配



## 3. 计算机网络结构

### 3.1 网络边缘

#### 3.1.1主机

位于网络边缘；运行网络应用程序

#### 3.1.2 网络应用

客户client发送请求，接收server服务器响应；

#### 3.1.3 对等(peer-peer）,P2P应用模型



### 3.2  接入网络，物理介质

有线或无线通信链路；

住宅接入网络；机构接入网络；移动接入网络； 

~~~
用户关心：
	带宽bps；共享/独占？
~~~

#### 3.2.1 DSL

Digital Subscriber Line数字用户线路



利用已有的电话线链接中心局的DSLAM

<2.5Mbps上行传输速录（典型速率<1Mbps）

<24Mbps下行传输速率（典型速率<10)

FDM：>50kHz

独占



#### 3.2.2 电缆网络

频分多路复用：在不通频带上传输不同频道

下行30Mbps，上行2Mbps

共享



#### 3.2.3 机构接入网络

主要用于公司高校企业

典型传输速率，10Mbps,100Mbos,1Gbps,10Gbps

端系统通常直接连接以太网交换机（SWITCH）



#### 3.2.4 无线接入网络

通过共享的无线接入网络连接端系统与路由器

无线局域网（LANS）：同一建筑物内

广域无线接入：通过运营商



### 3.3 网络核心

互联的路由器，交换机；网络之网络（更大范围的网络互联）

关键功能：路由+转发

解决的基本问题：数据交换



#### 3.3.1 路由

确定分组从源到目的传输路径

#### 3.3.2 转发

将分组从路由器的输入端口交换至正确的输出端口

#### 3.3.3 网络之网络

端系统通过 接入ISP（Internet Service Provider） 连接到Internet：家庭、公司、大学ISPS

接入ISP必须进一步互连：这样任意两个主机才可以互相发送分组

构成复杂的网络互连的网络：经济和国家政策是网络演进的主要驱动力

 

## 4. 数据交换

### 4.1电路交换

适合实时数据流传输

最典型的：电话网络  用户线——交换机—...交换机...——交换机——用户线

三个阶段：

​	建立连接：呼叫/电路建立

​	通信

​	释放连接：拆除电路

独占资源

#### 4.1.1 链路共享：多路复用

​	链路/网络资源划分为资源片

​	将资源片分配给各路呼叫calls

​	每路呼叫独占分配到的资源片进行通信

​	资源片可能闲置



典型多路复用方法：

##### 	频分多路复用

​		各用户占用不同的频率带宽；用户在分配一定的频带后，在通信过程中自始至终都占用这个频带。

##### 	时分多路复用

​		将时间划分为一段段等长的时分复用帧，每个用户在每个帧中占用固定的时隙，每用户所占用的时隙是周期性出现。所有用户在不同时间内占用同样的频率带宽。

##### 	波分多路复用

​		光的频分复用

##### 	码分多路复用

​		广泛应用于无线链路共享；

​		每个用户分配一个唯一的m bit码片序列（其中0用-1表示，1用+1表示）；

​		各用户使用相同频率载波，利用各自码片序列编码数据；

​		编码信号=原始数据 x 码片序列；

​		如发送+1，则发送自己码片序列，如果发送-1，则发送码片序列的反码

​		各用户码片序列相互正交

​		解码：码片序列与编码信号的内积



码分多路复用也是一种共享信道的方法,每个用户可在同一时间使用同样的频带进行通信,但使用的是基于码型的分割信道的方法,即每个用户分配一个[地址码](https://baike.baidu.com/item/地址码),各个码型互不重叠,通信各方之间不会相互干扰,且抗干拢能力强。



### 4.2 报文交换

​	报文：源（应用）发送信息整体

​	报文交换：

​		报文长度为M bits

​		链路带宽为R bps

​		每次传输报文需要M/R秒

​	报文交换中，中间的路由器需要至少M bits的缓存区



### 4.3 分组交换 package switching

适合突发数据流传输

​	分组：报文拆分出来的一系列相对较小的数据包。 头部信息+数据=分组

​	分组交换需要报文的拆分与重组;产生额外开销

​	分组交换：

​		报文被拆分为多个分组

​		分组长度为L bits

​		每个分组传输时延为L/R秒

​		T = M/R + nL/R(链路带宽全部相同)

​									（若不相同，则后半部分为最后一个分组通过n个路由器的时间）

~~~
例：
	所有链路的数据传输速率为100Mbps,分组大小为1000B，其中分组头大小为20 B.若主机H1向主机H2发送一个大小为980 000 B的文件，两个路由器，则在不考虑分组拆装时间的传播延迟的情况下，从H1发送开始到H2接手完为止，需要的时间至少是多少？
	
解：
	共分为980 000 / （1000 - 20） = 1000个组
	包M = 980 000 + 20 * 1000 = 1 000 000B = 8 000 000bit
	T = M / R + nL / R = 80 + 0.16 = 80.16ms
	    一个包的时间+最后一个分组通过两个路由器的时间
~~~



~~~
分组交换为什么会发生丢包和时延？
	分组在路由器缓存中排队
	分组到达速率超出链路容量
	路由器缓存不够
~~~



#### 4.3.1 分组时延

##### 4.3.1.1 结点处理时延 nodal processing delay

差错检测

确定输出链路

通常<msec



##### 4.3.1.2 排队时延 queueing delay

等待输出链路可用

取决于路由器拥塞程度

分组长度L bits

链路带宽bps

平均分组到达速率a

流量强度= La/R

​	La/R~0:平均排队延迟很小

​	La/R~1:平均排队延迟很大

​	La/R>1:平均排队延迟无限大



##### 4.3.1.3 传输延迟 transmission delay

​		发送主机：

​			接收应用报文

​			拆分为较小长度为L bits的分组

​			在传输速率为R的链路上传输分组

​			n个路由器

​	

​	分组传输 延迟（时延delay） = L（bits) / R(bits/sec)



##### 4.3.1.4 传播延迟 propagation delay

物理链路长度d

信号传播速度s

delay = d/s



~~~
类比：车队
	车速为100km/h~~~信号传播速度
	收费站放行一台车用时12秒~~~比特传输时间
	车~~~比特： 车队~~~分组
	车队通过收费站时间~~~传输延迟120秒
	每台车从第一个收费站跑到第二个收费站用时~~~传播延迟1小时
~~~



#### 4.3.2 分组丢失（丢包）

队列缓存有限

分组到达已满队列将被丢弃

丢弃分组可能由前序结点或源重发（也可能不重发）

丢包率 = 丢包数 / 已发分组总数



### 4.4 分组与报文

```
报文与分组交换均采用存储-转发 store-and-forward交换方式
区别：
	报文交换以完整报文进行“存储-转发”
	分组交换以较小的分组进行“存储-转发”
```

分组交换中，中间的路由器需要至少L bits的缓存区 时间大约为 报文交换的时间/（路由器+1）

### 4.5 分组与电路

~~~
例：
	1Mbps链路
	N个用户，每个用户：
		活动时需100kbps
		平均活动时间10%
电路交换

	用户数：1Mbps/100kbps = 10

分组交换

	对于35个用户，大于10个用户同时活动的概率<0.0004

~~~

分组交换适用于突发数据传输网络

​	资源充分共享

​	简单、无需呼叫建立

可能产生拥塞（congestion)：分组延迟和丢失

​	需要协议处理可靠数据传输和拥塞控制



电路交换更适合实时数据流传输



## 5.计算机网络性能

#### 5.1 速率

​	往往指额定速率



#### 5.2 带宽

​	原本指信号具有的频带宽度，即最高频率与最低频率之差

​	网络的带宽通常是数字信道所能传送的最高数据率。



#### 5.3 时延带宽积

​	时延带宽积 = 传播时延 x 带宽

​	当第一个比特到达终点时，链路中存在多少比特。 

​	以比特为单位的链路长度。



#### 5.4 吞吐量Throughput

​	表示在发送端与接收端之间传送数据速率 b/s

​	即时吞吐量：给定时刻的速率

​	平均吞吐量：一段时间的平均速率

~~~
瓶颈链路 bottleneck link
	端到端路径上，限制端到端吞吐量的链路
	Rc 或 Rs 通常是瓶颈
~~~



## 6. 计算机网络体系结构

​	分层结构

​	每层遵循某个/些网络协议完成本层功能

​	计算机网络体系结构是计算机网络的各层及协议的集合

​	体系结构是一个计算机网络的功能层次及其关系的定义

​	体系结构是抽象的



### 6.1 基本概念

​	实体：表示任何可发送或接收信息的硬件或软件进程

​	协议：控制两个对等实体进行通信的规则的集合，***协议是水平的***

​	任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，***服务是垂直的***

​	下层协议的实现对上层的服务用户是透明的

​	同系统的相邻层实体间通过接口进行交互，通过服务访问点SAP，交换原语，指定请求的特定服务。



### 6.2 OSI参考模型

#### 6.2.1 通信过程

![](D:\项目\markdown\计算机网络\OSI的通信过程.png)

#### 6.2.2 数据封装与通信过程

![](D:\项目\markdown\计算机网络\OSI参考模型数据封装与通信过程.png)

​											数据链路层加头加尾，物理层变成一系列比特

为什么需要数据封装？

​	增加控制信息：

​		**构造协议数据单元（PDU)**

​	控制信息主要包括：

​			**地址Address** ： 标识发送端/接收端；

​			**差错检测编码Error-detecting code**：用于差错检测或纠正；

​			**协议控制Protocol control：** 实现协议功能的附加信息，如：优先级、服务质量、安全控制



### 6.3 OSI七层结构

#### 6.3.1 应用层

网络服务与最终用户的一个接口。

![](D:\项目\markdown\计算机网络\应用层.png)

**支持用户通过用户代理（如浏览器）或网络接口使用网络（服务）**

**典型应用层服务：**

​	文件传输（FTP）、电子邮件（SMTP）、Web（HTTP）

报文 message

协议有：HTTP FTP TFTP SMTP SNMP（简单网络管理协议） DNS TELNET HTTPS POP3 DHCP



#### 6.3.2 表示层

处理两个系统间交换信息的语法语义(syntax and sematics)问题

**数据表示转化**

​	转换为主机独立的编码

**加密/解密**

**压缩/解压缩**



![](D:\项目\markdown\计算机网络\表示层.png)

格式有，JPEG、ASCll、EBCDIC、加密格式等 



#### 6.3.3 会话层

**对话控制 dialog controlling**

​	建立、维护、终止

**同步** synchronization

​	在数据流中插入“同步点”

**最薄的一层**





![](D:\项目\markdown\计算机网络\会话层.png)



#### 6.3.4 传输层

负责源-目的（端到端）（进程间）完整报文传输，为运行在不同主机上的进程彼此之间提供了逻辑通信

**分段与重组**

**SAP寻址**

​	确保将完整报文提交给正确进程，如端口号。

![](D:\项目\markdown\计算机网络\传输层SAP寻址.png)

**连接控制**

**流量控制**

**差错控制**



![](D:\项目\markdown\计算机网络\传输层.png)

协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层





#### 6.3.5 网络层

**负责源主机到目的主机数据分组(packet)交付：**

​	可能穿越多个网络

**逻辑寻址 Logical addressing**	

​	进行逻辑地址寻址，实现不同网络之间的路径选择。

**路由 Routing**

​	路由器互连网络，并路由分组至最终目的主机

​	路径选择

**分组转发**

​	![](D:\项目\markdown\计算机网络\网络层分组转发.png)

提供了主机之间的逻辑通信

![](D:\项目\markdown\计算机网络\网络层.png)

传输包packet

协议有：ICMP IGMP IP（IPV4 IPV6）

​	ping : 能ping通同网段的节点，但却ping不通其他网段的所有节点，最可能的原因是本机网关设置错误，DNS不会影响内部子设备直接是否ping通，ping命令是跨操作系统的，二层交换机如果出现故障那么同网段主机则不会ping通



#### 6.3.6 数据链路层

**负责结点-结点node-to-node数据传输**

**组帧 Framing**

​	将比特组合成字节进而组合成帧

**物理寻址 Physical addressing** 

​	在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端

**流量控制 Flow control：**

​	避免淹没接收端

**差错控制 Error control**

​	检测并重传损坏或丢失帧，并避免重复帧。

**访问接入控制 Access control**

​	在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权

![](D:\项目\markdown\计算机网络\数据链路层.png)

传输帧 **frame**（以太网最小帧64B）



#### 6.3.7 物理层

**实现每一个比特的传输。**

**接口特性：**

​	机械特性、电气特性、功能特性、规程特性

**比特编码：**

**数据率：**

**比特同步：**

​	时钟同步

**传输模式：**

​	单工（Simplex)

​	半双工（half-duplex)

​	全双工（full-duplex）	

建立、维护、断开物理连接。（由底层网络定义协议）

![](D:\项目\markdown\计算机网络\物理层.png)

传输比特 **bit**



### 6.4 TCP/IP参考模型

![](D:\项目\markdown\计算机网络\TCPIP参考模型.png)

网络接口层不定义协议



### 6.5 5层参考模型

##### 6.5.1 分层

**应用层：**支持各种网络应用：FTP,SMTP,HTTP  

**传输层：**进程-进程的数据传输：TCP,UDP

**网络层：**源主机到目的主机的数据分组路由与转发：IP协议、路由协议

**链路层：**相邻网络元素（主机、交换机、路由器等）的数据传输：以太网（Ethernet)、802.11（WIFI）、PPP

**物理层：**比特传输



##### 6.5.2 5层模型的数据封装

![](D:\项目\markdown\计算机网络\5层模型的数据封装.png)

应用层：message 报文

传输层：segment 报文段

网络层：datagram 数据报

链路层：frame 数据帧

物理层：bite 比特



## 7. 应用层

### 7.1 网络应用的体系结构

#### 7.1.1 客户机/服务器结构（Client-Server,C/S)

**服务器：**

​	7*24小时提供服务

​	永久性访问地址/域名

​	利用大量服务器实现可扩展性

**客户机：**

​	与服务器通信，使用服务器提供的服务

​	间歇性接入网络

​	可能使用动态IP地址

​	不会与其他客户机直接通信



例子：Web

​	![](D:\项目\markdown\计算机网络\CS_web.png)



#### 7.1.2 点对点结构（Peer-to-Peer,P2P)

没有永远在线的服务器

任意端系统/节点之间可以直接通讯

节点间歇性接入网络

节点可能改变IP地址



优点：**高度可伸缩**

缺点：**难于管理**



#### 7.1.3 混合结构（Hybrid)

Napster:

​	文件传输使用P2P结构

​	文件的搜索采用C/S结构——集中式

​		每个节点向中央服务器登记自己的内容

​		每个节点向中央服务器提交查询请求，查询感兴趣的内容



### 7.2 网络应用进程通信

**进程**：主机上运行的程序

**客户机进程**：发起通信的进程

**服务器进程：**等待通信请求的进程

~~~
1.同一主机上运行的进程之间如何通信？
	进程间通信机制
	操作系统提供
	
2.不同主机上运行的进程间如何通信？
	消息交换
~~~



#### 7.2.1 套接字Socket

**进程间通信利用socket发送/接收消息实现**

**类似于寄信**

​	发送方将消息送到门外邮箱

​	发送方依赖（门外）传输基础设施将消息传到接收方所在主机，并送到接收方的门外

​	接收方从门外获取消息

**传输基础设施向进程提供API**

​	传输协议的选择

​	参数的设置



#### 7.2.2 如何寻址进程？

不同主机上的进程间通信，那么每个进程必须拥有**标识符**

如何寻址主机？——IP地址

​	Q：主机有了IP地址后，是否足以定位进程？

​	A：否。同一主机上可能同时有多个进程需要通信

**端口号/Port number**

​	为主机上每个需要通信的进程分配一个端口号

​	HTTP Server:80

​	FTP: 21

​	HTTPS: 443

​	TELNET:23

​	SMTP:25

**进程的标识符**

​	IP地址+端口号



### 7.3 应用层协议

#### 7.3.1 协议种类

网络应用需遵循应用层协议

公开协议

​	**由RFC（Requestrian For Comments)定义**

​	**允许互操作**

​	**HTTP,SMTP,......**

私有协议

​	**多数P2P文件共享应用**



#### 7.3.2 协议内容

**消息的类型type：**

​	请求消息

​	响应消息

**消息的语法syntax格式**：

​	消息中有哪些字段（field）

​	每个字段如何描述

![](D:\项目\markdown\计算机网络\HTTP请求消息的格式.png)

**字段的语义（semantics)**：

​	字段中的信息的含义

**规则（rules)**：

​	进程何时发送/响应消息

​	进程如何发送/响应消息



### 7.4 传输层 

#### 7.4.1 网络应用对传输服务的需求

**数据丢失（data loss)/可靠性（reliability）**

​	某些网络应用能够容忍一定的数据丢失：网络电话

​	某些应用要求100%可靠的数据传输：文件传输，telnet

**时间（timing)/延迟（delay)**

​	有些应用只有在延迟足够低时才“有效”

​	网络电话/网络游戏

**带宽（bandwidth)**

​	某些应用只有在带宽达到最低要求时才“有效”：网络视频

​	某些应用能够适应任何带宽——弹性应用：email

​	

#### 7.4.2 Internet 提供的传输服务

##### 7.4.2.1 TCP服务：

​	**面向连接**：客户机/服务器进程间需要建立连接

​	**可靠的传输**

​	**流量控制：**发送方不会发送速度过快，超过接收方的处理能力

​	**拥塞控制：**当网络负载过重时，能够限制发送方的发送速度

​	**不提供时间/延迟保障**

​	**不提供最小带宽保障**



##### 7.4.2.2 UDP服务：

​	**无连接**

​	**不可靠的数据传输**

​	不提供：可靠性保障；流量控制；拥塞控制；延迟保障‘带宽保障；

![](D:\项目\markdown\计算机网络\典型的传输层服务.png)



## 8. Web应用

### 8.1 Web概念

**World Wide Web:** 

​	网页；网页互相链接

**网页（Web Page)包含多个对象（Objects)**

​	对象：HTML文件、JPEG图片、视频文件、动态脚本等

​	基本HTML文件：包含对其它对象引用的链接

**对象的寻址（addressing）**

​	URL（Uniform Resource Locator): 统一资源定位器

​	Scheme://host:port/path

![](D:\项目\markdown\计算机网络\Scheme.png)



### 8.2 Http协议

#### 8.2.1 **超本文传输协议：**HyperText Transfer Protocol

**C/S结构**：

​	客户——Browser:请求、接收、展示Web对象

​	服务器——Web Server: 响应客户的请求，发送对象

**HTTP版本：**

​	1.0: RFC 1945

​	1.1: RFC 2068



#### 8.2.2 使用TCP传输服务

​	服务器在80端口等待客户的请求

​	浏览器发起到服务器的TCP连接（创建套接字Socket)

​	服务器接受来自浏览器的TCP连接

​	浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息

​	关闭TCP连接



#### 8.2.3 无状态（stateless）

​	服务器不维护与任何有关客户端过去所发请求的信息



### 8.3 HTTP连接

##### 8.3.1 非持久性连接（Nonpersistent HTTP)

​	每个TCP连接最多允许传输一个对象

​	HTTP 1.0版本使用非持久性连接

![](D:\项目\markdown\计算机网络\HTTP非持久性连接.png)

![](D:\项目\markdown\计算机网络\HTTP非持久性连接2.png)

**RTT**

​	从客户端发送一个很小的数据包到服务器，并返回所经历的时间



**响应时间**Response time

​	发起、建立TCP连接：1个RTT

​	发送HTTP请求消息到HTTP响应消息的前几个字节到达：1个RTT

​	响应消息中所含的文件/对象传输时间



**每个对象需要TOTAL = 2RTT + 文件发送时间**

![](D:\项目\markdown\计算机网络\HTTP响应时间.png)



**非持久性连接的问题：**

​	每个对象需要2个RTT

​	操作系统需要为每个TCP连接开销资源（overhead）

​	浏览器会怎么做？

​			打开多个并行的TCP连接以获取网页所需对象

​			





##### 8.3.2 持久性连接（Persistent HTTP)

​	每个TCP连接允许传输多个对象

​	HTTP 1.1版本默认使用持久性连接



​	发送响应后，服务器保持TCP连接的打开

​	后续的HTTP消息可以通过这个连接发送

​	

​	**无流水的(pipelining)的持久性连接：**

​		客户端只有收到一个响应后才发送新的请求

​		每个被引用的对象耗时1个RTT



​	**带流水机制的持久性连接：**

​		HTTP 1.1的默认选项

​		客户端只要遇到一个引用对象就尽快发出请求

​		理想情况下，收到所有的引用对象只需耗时约1个RTT



### 8.4 HTTP消息

#### 8.4.1 请求消息

​	ASCII：人直接可读

![](D:\项目\markdown\计算机网络\HTTP请求通用格式.png)

HTTP请求消息格式

http报文结构由请求行，请求头，空行、请求正文组成（Get请求，没有请求正文）

**请求行：**请求方法、url、版本号

**请求头：**Host:接收请求的服务器地址，可以是ip也可以是端口号

​       User-Agent：发送请求的应用程序名称

​       Connection:指定与连接相关的属性，Connection:Keep-Alive

​       Accept-Charset:指定可接收的编码格式

​       Accept-Encoding:指定可接收的数据压缩格式

​       Accept-Language:指定可以接收的语言

**空行：**表示请求头结束

**请求正文：**可选，get就没有请求正文

![](D:\项目\markdown\计算机网络\HTTP请求消息例.png)

​																HTTP请求消息——实例

##### POST方法

​	网页经常需要填写表格（form)

​	在请求消息的消息体（entity body）中上传客户端的输入

​	POST 请求可能会导致新的资源的建立和/或已有资源的修改。

##### GET方法

​	请求指定的页面信息，并返回实体主体。

​	输入信息通过request行的URL字段上传



#####  方法类型

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序号 | 方法    | 描述                                                         |
| :--- | :------ | :----------------------------------------------------------- |
| 1    | GET     | 请求指定的页面信息，并返回实体主体。                         |
| 2    | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3    | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4    | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| 5    | DELETE  | 请求服务器删除指定的页面。                                   |
| 6    | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| 7    | OPTIONS | 允许客户端查看服务器的性能。                                 |
| 8    | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| 9    | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

​	

#### 8.4.2 响应消息

![](D:\项目\markdown\计算机网络\HTTP响应消息例.png)

​															HTTP响应消息实例

http响应报文由状态行、响应头、空行、响应正文四部分组成

 

**状态行：**协议版本、状态码、状态描述，之间用空格分开

**响应头：**Server:服务器应用程序软件的名称和版本号

​       Content-Type:响应正文的类型（是图片还是二进制）

​       Content-Length:响应正文的长度

​       Content-Charset:响应正文的使用编码

​       Content-Encoding:响应正文使用的数据压缩格式

​       Content-Language:响应正文使用的语言

**空行：**表示响应头结束

**响应正文**



##### 8.4.2.1 HTTP响应状态码

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

​	HTTP状态码列表:

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| :----- | :------------------------------ | :----------------------------------------------------------- |
| 100    | Continue                        | 继续。[客户端](http://www.dreamdu.com/webbuild/client_vs_server/)应继续其请求 |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

### 8.5 Cookie技术

​	HTTP协议无状态（服务器不维护与任何有关客户端过去所发请求的信息），很多应用需要服务器掌握客户端的状态。——引入Cookie

#### 	8.5.1 **Cookie技术**

​		某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据（通过经常加密）

​		RFC6265



#### 	8.5.2 Cookie的组件

​		HTTP响应消息的cookie头部行

​		HTTP请求消息的cookie头部行

​		保存在客户端主机上的cookie文件，由浏览器管理

​		Web服务器端的后台数据库

![](D:\项目\markdown\计算机网络\cookie原理.png)

​																		cookie原理

#### 	8.5.3 Cookie的作用

​		Cookie能够用于：

​			身份认证

​			购物车

​			推荐

​			Web e-mail

​		隐私问题



### 8.6 Web缓存/代理服务器技术

#### 8.6.1 概念

功能：

​	在不访问服务器的前提下满足客户端的HTTP请求

为什么发明这种技术？

​	缩短客户请求的响应时间

​	减少机构/组织的流量

​	在大范围内实现有效的内容分发

##### 8.6.2 WEB缓存/代理服务器

​	用户设定浏览器通过缓存进行Web访问

​	浏览器向缓存/代理服务器发送所有的HTTP请求

​		如果所请求对象在缓存中，缓存返回对象

​		否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回客户端并保存该对象

**缓存既充当客户端，也充当服务器**

**一般由ISP（Internet服务提供商）架设**



##### 8.6.3 WEB缓存示例

###### 8.6.3.1 缓存示例一

例：

![](D:\项目\markdown\计算机网络\WEB缓存1.png)

**假定：**
	对象的平均大小=100，000比特
	机构网络中的浏览器平均每秒有15个到原始服务器的请求
	从机构路由器到原始服务器的往返延迟=2秒

**网络性能分析：**
	局域网的利用率=15%
	接入互联网的链路的利用率=100%
	总的延迟=互联网上的延迟+访问延迟+局域网延迟=2秒+几分钟+几微秒



###### 8.6.3.2 缓存示例二

​	解决方案一：提升互联网接入带宽=10Mbps

![](D:\项目\markdown\计算机网络\WEB缓存2.png)

**网络性能分析：**

​	局域网利用率= 15%

​	接入互联网的链路的利用率=15%

​	总的延迟=互联网上的延迟+访问延迟+局域网延迟=2秒+几微秒+几微秒

**问题：**

​	成本太高



###### 8.6.3.2 缓存示例三

​	解决方案二：安装Web缓存，假定缓存命中率是0.4

![](D:\项目\markdown\计算机网络\WEB缓存3.png)

**网络性能分析：**

​	40%的请求立刻得到满足

​	60%的请求通过原始服务器满足

​	接入互联网的链路的利用率下降到60%，从而其延迟可以忽略不计，例如10微妙

​	总的平均延迟=互联网上的延迟+访问延迟+局域网延迟=0.6 x 2.01秒+0.4 x n微秒 < 1.4秒



### 8.7 条件性GET方法

目标：

​	如果缓存有最新的版本，则不需要发送请求对象

缓存：

​	在HTTP请求消息中声明所持有版本的日期

​	IF-MODIFIED-SINCE:<DATE>

服务器：

​	如果缓存器的版本是最新的，则响应消息中不包含对象

​	HTTP/1.0 304 NOT MODIFIED

![](D:\项目\markdown\计算机网络\条件性GET方法.png)



### 8.8 HTTP补充

#### 8.8.1 HTTP2.0

1.头信息和数据体都是二进制，称为头信息帧和数据帧
2.复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“队头堵塞“,此双向的实时通信称为多工（Multiplexing）
3.引入头信息压缩机制（header compression）,头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度
4.HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）



#### 8.8.2 http1.0和http1.1的区别

1.长连接
HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，弥补了HTTP1.0每次请求都要创建连接的缺点
2.缓存处理
在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略
3.带宽优化和网络连接的使用
HTTP1.0中，存在一些浪费带宽的现象，例如：客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），方便了开发者自由的选择以便于充分利用带宽和连接
4.错误通知的管理
在HTTP1.1中新增24个状态响应码，如
409（Conflict）表示请求的资源与资源当前状态冲突；.
410（Gone）表示服务器上的某个资源被永久性的删除
5.Host头处理
在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）



#### 8.8.3 get和post的区别

1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。
2. Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。
3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。
4. Get执行效率却比Post方法好。Get是form提交的默认方法。



#### 8.8.4 HTTPS

**HTTPS**（Hypertext Transfer Protocol Secure：超文本传输安全协议）

HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。（SSL:安全套接字协议;TLS：传输层安全协议）



##### 工作流程

- 1、TCP 三次同步握手

- 2、客户端验证服务器数字证书

- 3、DH 密钥交换算法协商对称加密算法的密钥、hash 算法的密钥

  ​	它不是用来加密消息的，生成的是通信双方共享的会话密钥，必须保密，其值取决于通信双方的私钥和公钥信息

- 4、SSL 安全加密隧道协商完成

- 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。



##### 与HTTP区别

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。



##### 工作原理

![img](https://www.runoob.com/wp-content/uploads/2018/09/https-intro.png)

#### 8.8.5 HTTP/3.0

基于QUIC协议（QUICK UDP INTERNET CONECTION)

- 实现了类似TCP的流量控制、传输可靠性的功能。

  虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。

- 实现了快速握手功能。

  由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。**0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势**。

- 集成了TLS加密功能。

  目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。

- 多路复用，彻底解决TCP中队头阻塞的问题

  和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87dbOJ1DviaxJZrqUjyw86H8J6NjTEJbuWHyxzbYxXQjngBxHI72LIBJA/640?wx_fmt=png)



## 9. Email应用

### 9.1 Email构成

邮件客户端,邮件服务器，SMTP协议（Simple Mail Transfer Protocol)

![](D:\项目\markdown\计算机网络\Email构成.png)

 ![](D:\项目\markdown\计算机网络\Email应用示例.png)**异步应用**

​							Email应用示例



#### 9.1.1 邮件客户端user agent

读、写Email消息；与服务器交互，收、发Email消息；Outlook,Foxmail,Thunderbird；



#### 9.1.2 邮件服务器mail server

​	邮箱：存储发给该用户的Email

​	消息队列message queue:存储等待发送的Email



#### 9.1.3 SMTP协议

​	邮件服务器之间传递消息所使用的协议

​	客户端：发送消息的服务器

​	服务器：接收消息的服务器

**RFC 2821**

​	**使用TCP进行email消息的可靠传输**

​	**端口25**

​	**传输过程的三个阶段**

​		握手；消息的传输；关闭

​	**命令/响应交互模式**

​		命令（command):ASCII文本

​		响应（response):状态代码和语句

​	**Email消息只能包含7位ASCII码**



![](D:\项目\markdown\计算机网络\SMTP交互示例.png)

​																		SMTP交互示例



**使用持久性连接**

**要求消息必须由7位ASCII码构成**

**SMTP服务器利用CRLF.CRLF确定消息的结束**



| HTTP                           | SMTP                                 |
| ------------------------------ | ------------------------------------ |
| 拉式pull（把网页拉回本地）     | 推式push（把消息推送到接收方）       |
| 命令/响应交互模式              | 命令/响应交互模式                    |
| 命令和状态码都是ASCII码        | 命令和状态码都是ASCII码              |
| 每个对象封装在独立的响应消息中 | 多个对象在由多个部分构成的消息中发送 |





### 9.2 Email消息格式

SMTP：email消息的传输/交换协议

RFC 822:文本消息格式标准

​	头部行header：To;From;Subject

​	消息体body：消息本身；只能是ASCII字符

![](D:\项目\markdown\计算机网络\Emai'l消息格式.png)



#### 9.2.1 多媒体扩展

MIME：多媒体邮件扩展RFC 2045,2056

​	通过在邮件头部增加额外的行以声明MIME的内容类型

![](D:\项目\markdown\计算机网络\Email多媒体扩展.png)



### 9.3 邮件访问协议

![](D:\项目\markdown\计算机网络\邮件访问协议.png)

从服务器获取邮件

#### 9.3.1 POP：Post Office Protocol [RFC 1939]

​	认证/授权（客户端—服务器）和下载

​	POP3是无状态的

##### 9.3.1.1 认证过程

###### 	客户端命令

​		User:声明用户名；Pass：声明密码

###### 	服务器响应

​		+OK;-ERR

##### 9.3.1.2 事务阶段

​	List:  列出消息数量

​	Retr: 用编号获取消息

​	Dele: 删除消息

​	Quit:

![](D:\项目\markdown\计算机网络\POP3示例.png)

​																			上面认证阶段；下面事务阶段

##### 9.3.1.3 模式

**下载并删除模式**：用户如果换了客户端软件，无法重读该邮件

**下载并保持模式**：不同客户端都可以保留消息的拷贝



#### 9.3.2 IMAP:Internet Mail Access Protocol [RFC 1730]

​	更多功能；更加复杂；能够操纵服务器上存储的消息

**所有消息统一保存在一个地方：服务器**

**允许用户利用文件夹组织消息**

**IMAP支持跨会话（Session)的用户状态：**

​	文件夹的名字；文件夹与消息ID之间的映射

#### 9.3.3 HTTP

​	163，QQ Mail等



## 10. DNS

Internet上主机/路由器的识别问题

​	IP地址

​	域名：www.baidu.com

### 10.1 域名解析系统DNS

​	多层命名服务器构成的分布式数据库

​	应用层协议：完成名字的解析

​		Internet核心功能，用应用层协议实现

​		网络边界复杂



### 10.2 DNS服务

域名向IP地址的翻译

主机别名

邮件服务器别名

负载均衡：Web服务器



~~~
为什么不使用集中式的DNS?
	单点失败问题；流量问题；距离问题；维护性问题
~~~



### 10.3 分布式层次式数据库

![](D:\项目\markdown\计算机网络\DNS数据库.png)

**客户端想要查询ww.amazon.com的IP**

​	查询根服务器，找到com域名解析服务器

​	查询com域名解析服务器，找到amazon.com域名解析服务器

​	查询amazon.com域名解析服务器，获得www.amazon.com的IP地址



### 10.4 域名服务器

#### 10.4.1 根域名服务器

**本地域名解析服务器无法解析域名时，访问根域名服务器**

**根域名服务器**

​	如果不知道映射，访问权威域名服务器

​	获得映射

​	向本地域名服务器返回映射

~~~
全球13个域名服务器
~~~



#### 10.4.2 顶级域名服务器

TLD,top-level domain

负责com,org,net,edu等顶级域名和国家顶级域名，例如cn,uk,fr

​	Network Solutions维护com

​	Educause维护edu



#### 10.4.3 权威域名服务器

组织的域名解析服务器，提供组织内部服务器的解析服务

​	组织负责维护

​	服务提供商负责维护



#### 10.4.4 本地域名解析服务器

不严格属于层级体系

每个ISP有一个本地域名服务器：

​	默认域名解析服务器

当主机进行DNS查询时，查询被发送到本地域名服务器：

​	作为代理（proxy），将查询转发给（层级式）域名解析服务器系统



### 10.5 DNS查询方法

DNS查询示例
	Cis.poly.edu的主机想获得gaia.cs.umass.edu的IP地址

#### 10.5.1 迭代查询：

​	被查询服务器返回域名解析服务器的名字

![](D:\项目\markdown\计算机网络\DNS迭代查询.png)



#### 10.5.2 递归查询：

​	将域名解析的任务交给所联系的服务器

![](D:\项目\markdown\计算机网络\DNS递归查询.png)



### 10.6 DNS记录

#### 10.6.1 缓存和更新

只要域名解析服务器获得域名-IP映射，即**缓存**这一映射

​	**一段时间过后，缓存条目失效（删除）**

​	**本地域名服务器一般会缓存顶级域名服务器的映射**：

​			因此根域名服务器不经常被访问

​		

#### 10.6.2 记录

资源记录（RR，resource records) ![](D:\项目\markdown\计算机网络\DNS资源记录格式.png)

##### Type=A

​	Name:主机域名

​	Value:IP地址

##### Type=NS

​	Name:域（edu.cn)

​	Value:该域权威域名解析服务器的主机域名

##### Type=CHAME

​	Name:某一真实域名的别名：www.ibm.com - servereast.backup2.ibm.com

​	Value:真实域名

##### Type=MX

​	Value是与Name相对应的邮件服务器



### 10.7 DNS协议与消息

#### 10.7.1 协议：

​	查询和回复

​	消息格式相同

**消息头部**：

​	Identification:16位查询编号，恢复使用相同的编号

​	flags:查询或回复，期望递归，递归可用，权威回答

![](D:\项目\markdown\计算机网络\DNS协议格式.png)

~~~
如何注册域名？
	例子：刚建了一个公司Network Utopia
	在域名管理机构（如network solutions)注册域名networkutopia.com
		向域名管理机构提供你的权威域名解析服务器的名字和ip地址
		域名管理机构向com顶级域名解析服务器中插入两条记录
		（networkutopia.com,dns1.networkutopia.com,NS)
		(dns1.networkutopia.com,212.212.212.1,A)
		在权威域名解析服务器中为www.networkutopia.com加入Type A记录，为networkutopia.com加入Type MX记录
~~~



## 11. P2P应用

### 11.1 原理

没有服务器

任意端系统之间直接通信

节点阶段性接入Internet

节点可能更换IP地址

![](D:\项目\markdown\计算机网络\p2p_1.png)

**客户机-服务器**

服务器串行地发送N个副本：时间： NF/Us

客户机i需要F/di时间下载

Time = max{NF/Us, F/di}

时间与客户数线性增长

**P2P**

服务器必须发送一个副本

​	时间：F/Us

客户机i需要F/di时间下载

总共需要下载NF比特

最快的可能上传速率：Us+∑Ui



### 11.2 索引

#### 11.2.1 系统的索引：

​	信息到节点位置（IP地址+端口号）的映射

**文件共享（电驴）**：

​	利用索引动态跟踪节点所共享的文件的位置

​	节点需要告诉索引它拥有哪些文件

​	节点搜索索引，从而获知能够得到哪些文件

**即时消息（QQ）：**

​	索引负责将用户名映射到位置

​	当用户开启IM应用时，需要通知索引它的位置

​	节点检索索引，确定用户的IP地址



#### 11.2.2 集中式索引

内容和文件传输是分布式的，但是内容定位是高度集中式的

单点失效问题、性能瓶颈、版权问题



### 11.3 应用

**Skype**

本质上是P2P的：用户/节点对之间直接通信

私有应用层协议

采用层次是覆盖网络架构

索引负责维护用户名与IP地址间的映射

索引分布在超级节点上



## 12.套接字编程

![](D:\项目\markdown\计算机网络\网络程序设计接口.png)

![](D:\项目\markdown\计算机网络\应用编程接口.png)

### 12.1 几种典型的API

Berkeley UNIX

微软 WINSOCK

AT&T TLI



### 12.2 Socket API

Internet网络应用最典型的API接口

**通信模型：客户/服务器（C/S）**

应用进程间通信的抽象机制

![](D:\项目\markdown\计算机网络\SOCKEIAPI.png)

![](D:\项目\markdown\计算机网络\SOCKETAPI2.png)

标识通信端点（对外）：

​	IP地址+端口号

操作系统/进程如何管理套接字（对内）？

​	套接字描述符



### 12.3 Socket抽象

类似于文件的抽象

当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息

返回套接字描述符

![](D:\项目\markdown\计算机网络\Socket抽象.png)

#### 12.3.1 地址结构

~~~c
struct sockaddr_in{
	u_char sin_len;      //地址长度
	u_char sin_family    //地址族
	u_short sin_port;    //端口号
	struct in_addr sin_addr   //IP地址
	char sin_zero[8];         //未用（置0）
}
~~~

使用TCP/IP协议簇的网络应用程序声明端点地址变量时，使用结构sockaddr_in



### 12.4 Socker API 函数

#### 12.4.1 WSAStartup

~~~c
int WSAStartup(WORD wVersionRequested, LPWSADATA IpWSAData);
~~~

使用Socket的应用程序在使用Socket之前必须首先调用WSAStartup函数

两个参数：

	1. 指明程序请求使用的WinSock版本，其中高位字节指明副版本、低位字节指明主版本（十六进制整数，例如0x102表示2.1版）
 	2. 返回实际的WinSock的版本信息（指向WSADATA结构的指针）

~~~c
例：使用2.1版本的WinSock的程序代码段
	wVersionRequested = MAKENWORD(2,1);
	err = WSAStartup(wVersionRequested, &wsaData);
~~~



#### 12.4.2 WSACleanup

~~~c
int WSACleanup(void);
~~~

应用程序在完成对请求的Socket库的使用，最后要调用该函数

解除与Socket库的绑定

释放Socket库所占用的系统资源



#### 12.4.3 Socket

~~~c
sd = socket(protofamily,type,proto);
~~~

创建套接字

操作系统返回套接字描述符（sd）

第一个参数（协议族）：protofamily = PF_INET(TCP/IP)

第二个参数（套接字类型）：

~~~c
type = SOCK_STREAM,SOCK_DRGAM or SOCK_RAW(TCP/IP)
~~~

第三个参数（协议号）：默认为0

~~~java
例：创建一个流套接字的代码段
	struct protoent *p
	p = getprotobyname("tcp");
	SOCKET sd = socket(PF_INET,SOCK_STREAM,p->proto);
~~~



#### 12.4.4 Closesocket

~~~java
int closesocket(SOCKET sd);
~~~

**关闭一个描述符为sd的套接字**

**如果多个进程共享一个套接字，调用closesocket将套接字引用计数减1，减至0才关闭**

**一个进程中的多线程对一个套接字的使用无计数**：如果进程中的一个线程调用closesocket将一个套接字关闭，该进程中的其他线程也将不能访问该套接字

**返回值**：0成功；SOCKET_ERROR失败



#### 12.4.5 bind

~~~java
int bind(sd,localaddr,addrlen);
~~~

绑定套接字的本地端点地址

​	IP地址+端口号

参数：

​	套接字描述符（sd)

​	端点地址（localaddr)

客户程序一般不必调用bind函数



#### 12.4.6 listen

~~~java
int listen(sd,queuesize);
~~~

置服务器端的流套接字处于监听状态

​	仅服务器端调用

​	仅用于面向连接的流套接字

设置连接请求队列大小（queuesize)

返回值：0成功；SOCKET_ERROR：失败



#### 12.4.7 connect

~~~java
connect(sd,saddr,saddrlen);
~~~

客户程序调用connect函数来使客户套接字（sd）与特定计算机的特定端口(saddr)的套接字（服务）进行连接

仅用于客户端

可用于TCP客户端也可以用于UDP客户端

​	TCP客户端：建立TCP连接

​	UDP客户端：指定服务器端点地址



#### 12.4.8 accept

~~~java
newsock = accept(sd,caddr,caddrlen);
~~~

服务程序调用accept函数从处于监听状态的流套接字sd的客户连接请求队列中取出排在最前的一个客户请求，并且创建一个新的套接字来与客户套接字创建连接通道

​	仅用于TCP套接字、仅用于服务器

利用新创建的套接字

​	newsock与客户通信



#### 12.4.9 send sendto

~~~java
send(sd,*buf,len,flags);
sendto(sd,*buf,len,flags,destaddr,addrlen);
~~~

send函数TCP套接字（客户与服务器）或调用了connect函数的UDP客户端套接字

sendto函数用于UDP服务器端套接字与未调用connect函数的udp客户端套接字



#### 12.4.10 recv,recvfrom

~~~java
recv(sd,*buffer,len,flags);
recvfrom(sd,*buf,len,flags,senderaddr,saddrlen);
~~~

recv函数从TCP连接的另一端接收数据，或者从调用了connect函数的UDP客户端套接字接收服务器发来的数据

recvfrom函数用于从UDP服务器端套接字与未调用connect函数的UDP客户端套接字接收对端数据



12.4.11 setsockopt,getsockopt

~~~java
int setsockopt(int sd,int level,int optname,*optval,int optlen);
int getsockopt(int sd,int level,int optname,*optval,socklen_t *optlen);
~~~

setsockopt()函数用来设置套接字sd的选项参数

getsockopt()函数用于获取任意类型、任意状态套接口的选项当前值，并把结果存入optval

![](D:\项目\markdown\计算机网络\Socket函数小结.png)

![](D:\项目\markdown\计算机网络\Socket函数小结2.png)



### 12.5 Socket的服务类型

![](D:\项目\markdown\计算机网络\Socket服务类型.png)

TCP：可靠、面向连接、字节流传输、点对点

UDP：不可靠、无连接、数据报传输



### 12.6 关于网络字节顺序

TCP/IP定义了便准的用于协议头中的二进制整数表示：网络字节顺序（network byte order)

某些Socket API函数的参数需要存储为网络字节顺序（IP地址、端口号等）

可以实现本地字节顺序与网络字节顺序间转换的函数

​	htons:本地字节顺序->网络字节顺序（16bits)

​	ntohs:网络字节顺序->本地字节顺序（16bits)

​	htonl:本地字节顺序->网络字节顺序（32bits)

​	ntohl:网络字节顺序->本地字节顺序（32bits)



### 12.7 API调用基本流程

![](D:\项目\markdown\计算机网络\Socket调用基本流程.png)



### 12.8 解析服务器IP地址

客户端可能使用域名或IP地址标识服务器

IP协议需要使用32位二进制IP地址

需要将域名或IP地址转换为32位IP地址

​	函数inet_addr()实现点分十进制IP地址到32位IP地址转换

​	函数gethostbyname()实现域名到32位IP地址转换（返回一个指向结构hostent的指针）

~~~java
struct hostent{
	char FAR* h_name;             //official host name
	cahr FAR* FAR* h_aliases;     //other aliases
	short     h_addrtype;         //address type
    short     h_lengty;           //address length
    char FAR* FAR* h_addr_list;   //list of address
};
~~~



### 12.9 解析服务器端口号

客户端还可能使用服务名（HTTP）标识服务器端口

需要将服务名转换为熟知端口号

​	函数getservbyname() 返回一个指向servent的指针

~~~java
struct servent{
	char FAR*  s_name;   // official service name
	char FAR* FAR* s_aliases;   //other aliases
	short      s_port;          //port for this service
	char FAR*  s_proto;         //protocol to use
};
~~~



### 12.10 解析协议号

客户端可能使用协议名，指定协议

需要将协议名转换为协议号

​	函数getprotobyname()实现协议名到协议号的转换，返回一个指向结构protoent的指针

~~~java
struct protoent{
	char FAR*  p_name;      //official protocol name
	char FAR* FAR* p_aliases;   //list of aliases allowed
	short   p_proto;           //official protocol number
};
~~~



### 12.11 TCP客户端软件流程

确定服务器**IP地址**与**端口号**

创建套接字

**分配本地端点地址（IP地址+端口号）**

连接服务器（套接字）

遵循应用层协议进行通信

关闭/释放连接



### 12.12 UDP客户端软件流程

确定服务器**IP地址**与**端口号**

创建套接字

**分配本地端点地址（IP地址+端口号）**

指定服务器端点地址，构造UDP数据报

遵循应用层协议进行通信

关闭/释放套接字





### 12.13 客户端软件的实现-connectsock()

设计一个connectsock过程封装底层代码

~~~java
/* consock.cpp - connectsock */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <winsock.h>

#ifndef INADDR_NONE
#define INADDR_NONE 0xffffffff
#endif /*INADDR_NONE */

void errexit(const char *,...);
/*-------------------------------------------------
 *connectsock - allocate & connect a socket using TCP or UDP
 *--------------------------------------------------
 */

SOCKET connectsock(const char *host, const char *service, const chat *transport){
    struct hostent *phe; //pointer to host information entry
    struct servent *pse; //pointer to service information entry
    struct protoent *ppe; //pointer to protocol information entry
    struct sockaddr_in sin; //an Internet endpoint
    int s,type;
    
    memset(&sin,0,sizeof(sin));
    sin.sin_family = AF_INET;
}
~~~



#### 12.13.1 UDP客户端

设计connectUDP过程用于创建连接模式客户端UDP套接字

~~~java
/* conUDP.cpp - connectUDP */
#include <winsock.h>
SOCKET connectsock(const char *, const char *, const char *);
/*----------------------------------
 *connectUDP - connect to a specified UDP service
 *on a specified host
 *----------------------------------
 */
 SOCKET connectUDP(const char * host,const char *service){
 	return connectsock(host,service,"udp");
 }
~~~



#### 12.13.2 TCP客户端

~~~c
/* conUDP.cpp - connectUDP */
#include <winsock.h>
SOCKET connectsock(const char *, const char *, const char *);
/*----------------------------------
 *connectTCP - connect to a specified TCP service
 *on a specified host
 *----------------------------------
 */
 SOCKET connectTCP(const char * host,const char *service){
 	return connectsock(host,service,"tcp");
 }
~~~



#### 12.13.3 异常处理

![](D:\项目\markdown\计算机网络\socket异常处理.png)



~~~c
例一：访问DAYTIME服务的客户端（TCP）
DAYTIME服务
	获取日期和时间
	双协议服务（TCP、UDP)，端口号13
	TCP版利用TCP连接请求触发服务
	UDP版需要客户端发送一个请求

/* TCPdtc.cpp - main, TCPdaytime */
#include <stdlib.h>
#include <stdio.h>
#include <winsock.h>

void TCPdaytime(const char *, const char *);
void errexit(const char *,...);
SOCKET connectTCP(const char *,const char *);

#define LINELEN 128
#define wsvers makeword(2,0)
/*--------------------------------------------
 *main - TCP client for DAYTIME service
 *--------------------------------------------
 */

int main(int argc,char * argv[]){
    char *host = "localhost";       //host to use if none supplied
    char *service = "daytime";      //default service port
    WSADATA wsadata;
    switch(argc){
        case 1:
            host = "localhost";
            break;
        case 3:
            service = argv[2];
        case 2:
            host = argv[1];
            break;
        default:
            fprintf(stderr,"usage:TCPdaytime [host[port]]\n");
            exit(1);
    }
    if(WSAtartup(WSVERS,&wsadata) != 0)
        errexit("WSAStartup failed\n");
    TCPdaytime(host,service);
    WSACleanup();
    return 0;
}
/*--------------------------------------
 *TCPdaytime - invoke Daytime on specified host and print results
 *--------------------------------------
 */

void TCPdaytime(const char *host,const char*service){
    char buf[LINELEN + 1];        //buffer for one line of text
    SOCKET s;                     //socket descriptor
    int cc;                       //recv character count
    s = connectTCP(host,service);
    cc = recv(s,buf,LINELEN,0);
    while(cc != SOCKET_ERROR && CC > 0){
        buf[cc] = '\0';
        (void) fputs(buf,stdout);
        cc = recv(s,buf,LINELEN,0);
    }
    closesocket(s);
    
    
}
~~~



### 12.14 服务器软件设计

**4种类型基本服务器**

#### 12.14.1 循环无连接

创建套接字

绑定端点地址（INADDR_ANY + 端口号）

反复接收来自客户端的请求

遵循应用层协议，构造响应报文，发送给客户

~~~
数据发送：
	服务器端不能使用connect()函数
	无连接服务器使用sendto()函数发送数据报

获取客户端点地址：
	调用recvfrom()函数接收数据时，自动提取
~~~



#### 12.14.2 循环面向连接

创建套接字，并绑定熟知端口号；

设置套接字为被动监听模式，准备用于服务器；

调用accept()函数接收下一个连接请求（通过主套接字），创建新套接字用于与该客户建立连接；

遵循应用层协议，反复接收客户请求，构造并发送响应；

完成为特定客户服务后，关闭与该客户之间的连接，返回步骤3



#### 12.14.3 并发无连接

主线程1：创建套接字，并绑定熟知端口号；

主线程2：反复调用recvfrom()函数，接收下一个客户请求，并创建新线程处理该客户相应；

子线程1：接收一个特定请求；

子线程2：依据应用层协议构造响应报文，并调用sendto()发送；

子线程3：退出（一个子线程处理一个请求后即终止）。



#### 12.14.4 并发面向连接

主线程1：创建套接字，并绑定熟知端口号；

主线程2：设置套接字为被动监听模式，准备用于服务器；

主线程3：反复调用accept()函数接收下一个连接请求（通过主套接字），并创建一个新的子线程处理该客户响应；

子线程1：接收一个客户的服务请求（通过创建新的套接字）；

子线程2：遵循应用层协议与特定客户进行交互；

子线程3：关闭/释放连接并推出（线程终止）。 



### 12.15 服务器的实现

设计一个底层过程隐藏底层代码：

​	passivesock();

两个高层过程分别用于创建服务器端UDP套接字和TCP套接字（调用passivesock()函数）；

​	passiveUDP();

​	passiveTCP();

![](D:\项目\markdown\计算机网络\无连接DAYTIME.png)

​								   图1 无连接循环DAYTIME服务器

![](D:\项目\markdown\计算机网络\面向连接并发DAYTIME.png)

​								  图2 面向连接并发DAYTIME服务器



## 13. 传输层

传输层协议为运行在不同Host上的进程提供了一种逻辑通信机制

端系统运行传输层协议：

​	**发送方：**将应用递交的消息分成一个或多个的Segment，并向下传给网络层

​	**接收方：**将接收到的segment组装成消息，并向上交给应用层。	

![](D:\项目\markdown\计算机网络\传输层VS网络层.png)

​																															图 网络层 VS 传输层



### 13.1 多路复用和多路分用

如果某层的一个协议对应直接上层的多个协议/实体，则需要复用/分用

例：

![](D:\项目\markdown\计算机网络\多路分用例子.png)

**接收端进行多路分用**：传输层依据头部信息将收到的Segment交给正确的Socket,即不同的进程。

**发送端进行多路复用**：从多个Socket接收数据，为每块数据封装上头部信息，生成Segment,交给网络层。



#### 13.1.1 分用

**分用如何工作？**
	主机接收到IP数据报（datagram）

​		每个数据报携带源IP地址、目的IP地址。

​		每个数据报携带一个传输层的段（Segment)

​		每个段携带源端口号和目的端口号

​	主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket

​		TCP做更多处理



##### 无连接分用

利用端口号创建Socket

~~~java
DatagramSocket mySocket1 = new DatagramSocket(99111);
DatagramSocket mySocket2 = new DatagramSocket(99222);
~~~

UDP的Socket用二元组标识（目的IP地址，目的端口号）

主机收到UDP段后

​	检查段中的目的端口号

​	将UDP段导向绑定在该端口号的Socket

来自不同源IP地址和/或源端口号的IP数据包被导向同一个Socket

![](D:\项目\markdown\计算机网络\无连接分用.png)

​													图    无连接分用实例



##### 面向连接分用

TCP的Socket用四元组标识：

​	源IP地址

​	源端口号

​	目的IP地址

​	目的端口号

接收端利用所有的四个值将Segment导向合适的Socket

服务器可能同时支持多个TCP Socket

​	每个Socket用自己的四元组标识

Web服务器为每个客户端开不同的Socket

![](D:\项目\markdown\计算机网络\面向连接的分用.png)



![](D:\项目\markdown\计算机网络\多线程面向连接的分用.png)

### 13.2 UDP

User Datagram Protocol

**基于Internet IP协议**

​	复用/分用

​	简单的错误校验

**Best effort 服务**

UDP段可能丢失；非按序到达

**无连接：**

​	UDP发送方和接收方之间不需要握手

​	每个UDP段的处理独立于其他段

#### 13.2.1 UDP为什么存在？

​	无需建立连接（减少延迟）
​	实现简单：无需维护连接状态
​	头部开销少
​	没有拥塞控制：应用可更好地控制发送时间和速率

#### 13.2.2 UDP用途

​	常用于流媒体应用

​		容忍丢失；速率感人

​	DNS

​	SNMP（简单网络管理协议）



#### 13.2.3 在UDP上实现可靠数据传输？

​	在应用层增加可靠性机制
​	应用特定的错误恢复机制



#### 13.2.4 UDP格式

![](D:\项目\markdown\计算机网络\UDP报文格式.png)



#### 13.2.5 UDP校验和

目的：检测UDP段在传输中是否发生错误（如位翻转）

**发送方**

​	将段的内容视为16-bit整数

​	校验和计算：计算所有整数的和，进位加在和的后面，将得到的值按位求反，得到校验和

​	发送方将校验和放入检验和字段

**接收方**

​	计算所收到段的校验和

​	将其与校验和字段进行对比

​		不相等：检测出错误

​		相等：没有检测出错误（但可能有错误）



**示例**：

![](D:\项目\markdown\计算机网络\校验和计算示例.png)



### 13.3 可靠传输协议

什么是可靠？

​	不错、不丢、不乱



#### 13.3.1 可靠协议基本结构：接口

![](D:\项目\markdown\计算机网络\TCP协议基本结构.png)



#### 13.3.2 Rdt 1.0

**//可靠信道上的可靠信道传输协议**

底层信道完全可靠：

​	不会发生错误；不会丢弃分组

发送方和接收方的FSM（有限状态机）独立



#### 13.3.3 Rdt 2.0

**//产生位错误的信道（不可靠的信道）传输协议**

底层信道可能翻转分组中的位（bit)

​	利用校验和检测位错误

如何从错误中恢复？

​	确认机制（ACK），接收方显示地告知发送方分组已正确接收

​	NAK（否定确认）：接收方显示地告知发送方分组有错误

​	发送方收到NAK后，重传分组

**基于这种重传机制的rdt协议称为ARQ（Automatic Repeat reQuest)协议**

Rdt 2.0 中引入的新机制

​	差错检测

​	接收方反馈控制消息：ACK/NAK

​	重传

缺陷：

​	**如果ACK/NAK消息发生错误/被破环怎么办？**

​	为ACK/NAK增加校验和，检错并纠错

​	发送方收到被破环ACK/NAK时不知道接收方发生了什么，添加额外的控制消息

​	如果ACK.NAK坏掉，发送方重传

​	不能简单的重传：产生重复分组



如何解决重复分组问题？

​	序列号：发送方给每个分组增加序列号

​	接收方丢弃重复分组



#### 13.3.4 Rdt 2.1

**发送方：**

​	为每个分组增加了序列号

​	两个序列号（0，1）就够用————停等协议

​	需校验ACK/NAK消息是否发生错误

​	状态数量翻倍，（必须记住当前分分组序列号）

**接收方：**

​	需判断分组是否重复

​		当前所处状态提供了期望收到分组的序列号

​	注意：接收方无法知道ACK/NAK是否被发送方正确收到



#### 13.3.4 Rdt 2.2

**//无NAK消息协议**

与Rdt 2.1 功能相同，但是只是用ACK

如何实现？

​	接收方通过ACK告知最后一个被正确接收的分组

​	在ACK消息中显示地加入被确认分组的序列号

发送方收到重复ACK之后，采取与收到NAK消息相同的动作

​	重传当前分组



#### 13.3.5 Rdt 3.0

##### 13.3.5.1 功能分析

如果信道既可能发生错误，也可能丢失分组，怎么办？

​	校验和+序列号+ACK+重传



方法：发送方等待“合理”时间

​	如果没有收到ACK，重传

​	如果分组或ACK只是延迟而不是丢了（重传会产生重复，序列号机制能够处理；接收方需在ACK中显示告知所确认的分组）

​	需要定时器



示例：

![](D:\项目\markdown\计算机网络\Rdt 3.0示例1.png)

![](D:\项目\markdown\计算机网络\Rdt 3.0示例2.png)



##### 13.3.5.2 性能分析

示例：1Gbps链路，15ms端到端传播延迟，1KB分组

T传输 = L（packet length in bits) / R(transmission rate,bps) = 1KB * 8 / 1 Gbps = 8微秒

发送方利用率：发送方发送时间百分比：

​	Usender = L/R  /(RTT + L / R) = 0.00027

在1Gbps链路上每30ms才发送一个分组->33KB/sec

网络协议限制了物理资源的利用



### 13.4 流水线与滑动窗口

#### 13.4.1 流水线机制

![](D:\项目\markdown\计算机网络\流水线机制.png)

流水线协议：

​	允许发送方在收到ACK之间连续发送多个分组

​		更大的序列号范围

​		发送方和/或接收方需要更大的存储空间以缓存分组



#### 13.4.2 滑动窗口协议

Sliding-window protocol

窗口：

​	允许使用的序列号范围

​	窗口尺寸为N：最多有N个等待确认的消息

滑动窗口：

​	随着协议的运行，窗口在序列号空间内向前滑动

滑动窗口协议：GBN,SR

![](D:\项目\markdown\计算机网络\滑动窗口.png)

黑色为已经发送且确认完成的包

黄色为已经发送但未确认的包

蓝色为还可以使用的序列号

白色为还未使用的序列号



##### Go-Back-N协议

###### 发送方

分组头部包含k-bit序列号

窗口尺寸为N，最多允许N个分组未确认

ACK（n)：确认到序列号n（包含n）的分组均已被正确接收

​	可能收到重复ACK

为空中的分组设置计时器（timer)

超时Timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组



###### 接收方

ACK机制：发送拥有最高序列号的、已被正确接收的分组的ACK

​	可能产生重复ACK

​	只需记住唯一expectedseqnum

乱序到达的分组：

​	直接丢弃->接收方没有缓存

​	重新确认序列号最大的、按序到达的分组

![](D:\项目\markdown\计算机网络\GBN示例.png)



##### Selective Repeat协议

接收方对每个分组单独进行确认

​	设置缓存机制，缓存乱序到达的分组

发送方只重传那些没收到ACK的分组

​	为每个分组设置定时器

发送方窗口

​	N个连续的序列号

​	限制已发送且未确认的分组

![](D:\项目\markdown\计算机网络\selective repeat.png)

![](D:\项目\markdown\计算机网络\SR协议.png)

![](D:\项目\markdown\计算机网络\SR协议示例.png)

困境：

​	![](D:\项目\markdown\计算机网络\SR困境.png)

序列号：0，1，2，3；窗口尺寸：3.

接收方对第二个序列号为0的包，无法判断是哪个0

Ns+Nr <= 2的k次方



### 13.5 TCP 

Transmission Control Protocol传输控制协议

**概述**
点对点：一个发送方，一个接收方

可靠的、按序的字节流

流水线机制

​	TCP拥塞控制和流量控制机制设置窗口尺寸

发送方/接收方缓存

全双工

​	同一连接中能够传输双向数据流

面向连接

​	通信双方在发送数据之前必须建立连接

​	连接状态只在连接的两端中维护，在沿途节点中并不维护状态。

​	TCP连接包括：两台主机上的缓存、连接状态变量、socket等

流量控制机制



#### 13.5.1 TCP段结构

![](D:\项目\markdown\计算机网络\TCP段结构.png)

**序列号：**

​	序列号指的是segment中第一个字节的编号，而不是segment的编号

​	建立TCP连接时，双方随机选择序列号

**ACKs：**

​	希望接收到的下一个字节的序列号

​	累计确认：该序列号之前的所有字节均已被正确接收到

**Q：接收方如何处理乱序到达的Segment?**

​	A:TCP规范中没有规定，由TCP的实现者做出决策

![](D:\项目\markdown\计算机网络\TCP传输数据.png)



#### 13.5.2 TCP可靠数据传输

**概述**

TCP在IP层提供的不可靠服务基础上实现可靠数据传输服务

流水线机制

累计确认

TCP使用单一重传定时器

触发重传的事件

​	超时；收到重复ACK

渐进式

​	暂不考虑重复ACK

​	暂不考虑流量控制

​	暂不考虑拥塞控制



##### RTT和超时

~~~
如何设置定时器的超时时间？

大于RTT

​	但是RTT是变化的

过短

​	不必要的重传

过长

​	对段丢失时间反应慢
~~~



~~~
如何估计RTT？

SampleRTT:测量从段发出去到收到ACK的时间

​	忽略重传

SampleRTT变化

​	测量多个SampleRTT，求平均值，形成RTT的估计值EstimatedRTT

EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT (指数加权移动平均典型值0.125)
~~~



定时器超时时间的设置：

​	EstimatedRTT + "安全边界"

​	EstimatedRTT变化大->较大的边界

测量RTT的变化值:SamoleRTT与EstimatedRTT的差值

​	DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|

​	(typically,β - 0.25)

定时器超时时间的设置：

​	TimeoutInterval = EstimatedRTT + 4 * DevRTT



##### 发送方事件

**从应用层收到数据**

​	创建Segment

​	序列号是Segment第一个字节的编号

​	开启计时器

​	设置超时时间：TimeOutInterval

**超时**

​	重传引起超时的Segment

​	重启定时器

**收到ACK**

​	如果确认此前未确认的Segment

​		更新SendBase

​		如果窗口中还有未被确认的分组，重新启动定时器

![](D:\项目\markdown\计算机网络\TCP重传示例1.png)

![](D:\项目\markdown\计算机网络\TCP重传示例2.png)



![](D:\项目\markdown\计算机网络\TCP的ACK生成.png)



##### 快速重传机制 

**TCP中，如果发生超时，超时时间间隔将重新设置，即将超时时间间隔加倍，导致其很大**

​	重发丢失的分组之前要等待很长时间

**通过重复ACK检测分组丢失**

​	Sender会背靠背地发送多个分组

​	如果某个分组丢失，可能会引发多个重复的ACK

**如果sender收到对同一数据的3个ACK，则假定该数据之后的段已经丢失**

​	快速重传：在定时器超时之前即进行重传

~~~
为什么是3？
	2次大概率是乱序
~~~



#### 13.5.3 流量控制

接收方为TCP连接分配buffer，上层应用可能处理buffer中数据的速度较慢

流量控制：

​	发送方不会传输的太多、太快以至于淹没接收方（buffer溢出）

本质上是速度匹配机制



接收方通过在Segment的头部字段将RcvWindow告诉Sender

Sender限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲RcvWindow尺寸

Receiver告知Sender RcvWindow = 0,会出现什么情况？

​	需要增加额外处理，即使= 0，也能发个很小的段



#### 13.5.4 连接管理

TCP sender 和 receiver 在传输数据前需要建立连接

初始化TCP变量

​	Seq.#

​	Buffer和流量控制信息

Client：连接发起者 Socket clientSocket = new Socket("hostname","port number");

Server：等待客户连接请求 Socket connectionSocket = welcomeSocket.accept();



##### 三次握手

![](D:\项目\markdown\计算机网络\三次握手.png)

Step 1:

​	客户端发送SYN = 1 给 服务端，同时有specifies initial seq #, no data

Step 2:

​	客户主机接到SYN = 1,回复SYN = 1，ack ，以及序列号，同时设置缓存

Step 3:

​	客户主机发送SYN = 0, ack,可能包含数据



**为什么要进行第三次握手？**

为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了SYN=1创建连接的请求(第一次握手)。

如果服务器端就直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。

客户端可能设置了一个超时时间，时间到了就关闭了连接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，

服务器端是不知道客户端有没有接收到服务器端返回的信息的。

这个过程可理解为：

![img](https://pics3.baidu.com/feed/1c950a7b02087bf4cf316c92aa0daf2913dfcfd4.jpeg?token=7e26ac525676d063251da3d6bf395e8a&s=3172483221D25DCA14F115DA0300E0B0)

这样没有给服务器端一个创建还是关闭连接端口的请求，服务器端的端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。那么服务器端上没有接收到请求数据的上一个端口就一直开着，长此以往，这样的端口多了，就会造成服务器端开销的严重浪费。

还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。

所以我们需要“第三次握手”来确认这个过程，让客户端和服务器端能够及时地察觉到因为网络等一些问题导致的连接创建失败，这样服务器端的端口就可以关闭了不用一直等待。

也可以这样理解：“第三次握手”是客户端向服务器端发送数据，这个数据就是要告诉服务器，客户端有没有收到服务器“第二次握手”时传过去的数据。若发送的这个数据是“收到了”的信息，接收后服务器就正常建立TCP连接，否则建立TCP连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。



##### 四次挥手

client closes socket: clientSocket.close();

![](D:\项目\markdown\计算机网络\四次挥手.png)

Step 1: 客户端向服务端发送TCP FIN = 1 控制报文段，客户端进入FIN-WAIT-1

Step 2:服务端收到FIN，向客户端发送ACK = 1，关闭连接，发送FIN =1,ACK= 1

Step 3:客户端收到FIN，回复ACK = 1，进入等待，如果收到FIN，会重新发送ACK

Step 4:服务器收到ACK = 1，连接关闭



**为什么“握手”是三次，“挥手”却要四次？**

TCP建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。

即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。

TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次"握手"传输的。为何建立连接时一起传输，释放连接时却要分开传输？

建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。

所以是“三次握手”，“四次挥手”。



**为什么客户端在TIME-WAIT阶段要等2MSL?**

为的是确认服务器端是否收到客户端发出的ACK确认报文

当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；

如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。

所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因



### 13.6 拥塞控制

非正式定义：太多发送主机发送了太多数据或者发送速度太快，以至于网络无法处理

表现；

​	分组丢失（路由器缓存溢出）

​	分组延迟过大（在路由器缓存中排队）

#### 13.6.1 拥塞成因

一

![拥塞成因一](D:\项目\markdown\计算机网络\拥塞成因一.png)

二

![](D:\项目\markdown\计算机网络\拥塞成因二.png)



![拥塞成因二点](D:\项目\markdown\计算机网络\拥塞成因二点.png)



三

![拥塞成因三](D:\项目\markdown\计算机网络\拥塞成因三.png)

![拥塞成因三点](D:\项目\markdown\计算机网络\拥塞成因三点.png)

#### 13.6.2 拥塞控制的方法

端到端拥塞控制：

​	网络层不需要显式的提供支持

​	端系统通过观察loss,delay等网络行为判断是否发生拥塞

​	TCP采取这种方法

网络辅助的拥塞控制：

​	路由器向发送方显示地反馈网络拥塞信息

​	简单的拥塞指示：SNA,DECbit,TCCP/IP ECN ATM

​	指示发送方应该采用何种速率

~~~
案例:ATM ABR 拥塞控制

ABR:available bit rate
弹性服务
如果发送方路径underloader,使用可用带宽
如果发送方路径拥塞，将发送速率降到最低保障速率

RM（resource management)
发送方发送
交换机设置RMcell 位
	NI bit:rate不许增长
	CI bit:拥塞指示
RM cell 由接收方返回给发送方
~~~

![](D:\项目\markdown\计算机网络\ATM ABR拥塞控制.png)



### 13.7 TCP拥塞控制

Sender限制发送速率

​	LastByteSent - LastByteAcked <= CongWin

​	rate ≈ CongWin/RTT

CongWin:

​	动态调整以改变发送速率

​	反应所感感知到的网络拥塞

问题：如何感知网络拥塞？

​	Loss事件 = timeout 或 3个重复ACK

​	发生LOSS事件后，发送方降低速率

如何合理地调整发送速率？

​	加性增-乘性减：AIMD

​	慢启动：SS



#### 13.7.1 AIMD

原理：逐渐增加发送速率，谨慎探测可用带宽，直到发生loss

方法：AIMD

​	Additive Increase: 每个RTT将CongWin增大一个MSS-----拥塞避免

​	Mutiplicative Decrease：发生loss后将CongWin减半



#### 13.7.2 SS

TCP连接建立时，CongWin = 1

例：MSS = 500 BYTE, RTT = 200MSEC 初始速率=20Kbps

可用带宽可能远远高于初始速率：

​	希望快速增长

原理：

​	当连接开始时，指数性增长（每个RTT将CongWin翻倍，收到每个ACK进行操作）

​	初始速率很慢，但是快速攀升



~~~
何时应该指数型增长切换为线性增长（拥塞避免）？
	当CongWin达到Loss事件前值的1/2时
~~~

实现方法：

​	变量Threshold

​	Loss事件发生时，Threshold被设为Loss事件前CongWin值的1/2

![](D:\项目\markdown\计算机网络\Threshold.png)

#### 13.7.3 Loss事件处理

3个重复ACKs:

​	CongWin切到一半，然后线性增长

Timeout事件：

​	CongWin直接设为1个MSS，然后指数增长，达到threshold后，再线性增长

~~~
Philosophy:
	3个重复ACKs表示网络还能够传输一些segments
	timeout事件表明拥塞更为严重
~~~

![](D:\项目\markdown\计算机网络\TCP拥塞控制例题.png)

解：Threshold = 16 /2 = 8KB,CongWin = 1 KB,1个RTT后，CongWin = 2KB,2个RTT后，CongWin = 4 KB,3个RTT后，CongWin = 8 KB,Slowstart is over； 4个RTT后，CongWin = 9 KB



### 13.8 TCP性能分析

#### 13.8.1 吞吐率

假定发生超时时，CongWin的大小为W，吞吐率是W/RTT

超时后，CongWin = W /2 ,吞吐率是W/2RTT

平均吞吐率为：075 W/RTT



#### 13.8.2 公平性

如果k个TCP session共享相同的瓶颈带宽R，那么每个Session的平均速率为R/K

**与UDP**

​	多媒体应用通常不使用TCP，以免被拥塞控制机制限制速率

​	使用UDP，以恒定速率发送，能够容忍丢失

​	产生了不公平

 与并发TCP连接

​	某些应用会打开多个并发连接

​	Web浏览器

​	产生公平性问题

~~~
例子：链路速率为R，已有9个连接
新来的应用请求1个TCP，获得R/10的速率
新来的应用请求11个TCP，获得R/2的速率
~~~



## 14. 网络层

 转发：将分组从路由器的端入口转移到合适的输出端口

转发表：确定在本路路由器如何转发分组

路由：确定分组从源到目的地经过的路径

路由算法：确定通过网络的端到端路径

ATM：异步传输网络

**网络层服务模型**

![](D:\项目\markdown\计算机网络\网络层服务模型.png)

尽力服务、固定比特率、可变比特率、可用比特率、不保证比特率



无连接服务

​	不事先为系列分组的传输确定传输路径

​	每个分组独立确定传输路径

​	不同分组可能传输路径不同

​	**数据报网络**



连接服务：

​	首先为系列分组的传输确定从源到目的经过的路径（建立连接）

​	然后沿该路径传输系列分组

​	系列分组传输路径相同

​	传输结束后拆除连接

​	**虚电路网络**



### 14.1 虚电路网络

一条从源主机到目的主机，类似于电路的路径（逻辑连接）

分组交换

每个分组的传输利用链路的全部带宽

源到目的路径经过的网络层设备共同完成虚电路功能

通信过程：

​	呼叫建立->数据传输->拆除呼叫

每个分组携带虚电路标识（VCID），而不是目的主机地址

虚电路经过的每个网络设备（如路由器），维护每条经过它的虚电路连接状态

链路、网络设备资源（如带宽、缓存等）可以面向VC进行预分配

​	预分配资源=可预期服务性能

​	如ATM的电路仿真（CBR）



每条虚电路包括：

​	1.从源主机到目的主机的一条路径

​	2.虚电路号（VCID），沿路每段链路一个编号

​	3.沿路每个网络层设备（如路由器），利用转发表记录经过的每条虚电路

沿某条虚电路传输的分组，携带对应虚电路的VCID，而不是目的地址

同一条VC，在每段链路上的VCID通常不同

​	路由器转发分组时依据转发表改写/替换虚电路号

![](D:\项目\markdown\计算机网络\VC转发表.png)

VC路径上每个路由器都需要维护VC连接的状态信息

#### 14.1.1 虚电路信令协议

用于VC的建立、维护与拆除

​	路径选择

应用于虚电路网络

​	如ATM、帧中继网络等

目前的Internet不采用

![](D:\项目\markdown\计算机网络\虚电路信令协议.png)



### 14.2 数据报网络

网络层无连接

每个分组携带目的地址

路由器根据分组的目的地址转发分组

​	基于路由协议/算法构建转发表

​	检索转发表

​	每个分组独立选路

![](D:\项目\markdown\计算机网络\数据报转发表.png)		



#### 14.2.1 最长前缀匹配优先

在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口



![](D:\项目\markdown\计算机网络\数据报网络orVC网络.png)



### 14.3 IP数据报![](D:\项目\markdown\计算机网络\网络层主要功能.png)

#### 14.3.1 IP数据报格式

![](D:\项目\markdown\计算机网络\IP数据报分组格式.png)

**版本号**：字段4位，IP协议的版本号

​	E.g。 4->IPv4, 6->IPv6

**首部长度**：字段4位，IP分组首部长度

​	以4字节为单位 E.g 5->IP首部长度为20（5×4）字节

**服务类型（TOS）**：字段8位，指示期望获得哪种类型的服务

·	一般情况下不使用，通常IP分组的该字段（第二字节）的值为00H

**总长度：**字段占16位，IP分组的总字节数（首部+数据）

​	最大IP分组的总长度：65535B

​	最小的IP分组首部：20B

​	IP分组可以封装的最大数据：65535-20 = 65515B

**生存时间（TTL）：**字段8位，IP分组在网络中可以通过的路由器数（或跳步数）

​	路由器转发一次分组：TTL减1

​	如果TTL = 0，路由器则丢弃该IP分组

**协议：**字段8位，指示IP分组封装的是哪个协议的数据包

​	实现复用/分解

​	E.g 6为TCP，表示封装的为TCP段；17为UDP，表示封装的是UDP数据报

**首部校验和：**字段16位，实现对IP分组首部的差错检测

​	计算校验和，该字段置全0

​	采用反码算数运算求和，和的反码作为首部校验和字段

​	逐跳计算，逐跳求和

**源IP地址、目的IP地址：**字段各占32位，分别标识发送分组的源主机/路由器（网络接口）和接受分组的目的主机/路由器（网络接口）的IP地址

**选项字段：**字段长度可变，范围1~40B之间：携带安全、源选路径、时间戳和路由记录等内容

​	实际上很少被使用

**填充字段：**占长度可变，范围在0~3B之间，补齐整个首部，符合32位对齐，保证首部长度是4字节的倍数



#### 14.3.2 IP数据报分片

最大传输单元（MTU）

网络链路存在MTU（最大传输单元）——链路层数据帧可封装数据的上限

​	不同链路的MTU不同

![](D:\项目\markdown\计算机网络\最大传输单元.png)

大IP分组向较小MTU链路转发时，可以被“分片”（fragmented)

​	1个IP分组分为多片IP分组

​	IP分片到达目的主机后进行重组

IP首部的相关字段用于标识分片以及确定分片的相对顺序

​	总长度、标识、片偏移

**标识：**字段16位，标识一个IP分组

​	IP协议用一个计数器，每产生IP分组计数器加1，作为该IP分组的标识

**标志位：**字段3位

​	DF（禁止分片），DF = 1，禁止分片，DF= 0，允许分片

​	MF（有更多分片），MF = 1,非最后一片，MF=0，最后一片（或为分片）

**片偏移：**字段13位，一个IP分组分片封装原IP分组数据的相对偏移量

​	片偏移字段以8字节为单位

![](D:\项目\markdown\计算机网络\IP分片过程.png)

![](D:\项目\markdown\计算机网络\IP分片过程2.png)



**例题**

![](D:\项目\markdown\计算机网络\IP分片例.png)



### 14.4 IP编址(addressing)

##### **IP分组：**

​	源地址-从哪儿来

​	目的地址：到哪儿去

##### **接口：**主机/路由器与物理链路的连接

​	实现网络层功能

​	路由器通常有多个接口

​	主机通常只有一个或两个接口（e.g. 有线的以太网接口，无线的802.11接口）





##### **IP地址：**32比特（IPV4）

​	编号标识主机、路由器的接口

![](D:\项目\markdown\计算机网络\IP编址.png)

IP地址与每个接口关联



#### 14.4.1 IP子网(subnets)

IP地址：

​	网络号——高位比特

​	主机号——低位比特

IP子网：

​	IP地址具有相同网络号的设备接口

​	不跨越路由器（第三及以上层网络设备）可以彼此物理联通的接口



### 14.5 有类IP地址

![](D:\项目\markdown\计算机网络\有类编址.png)

D类：多播地址，组播地址



#### 14.5.1 特殊IP地址

![](D:\项目\markdown\计算机网络\特殊IPD地址.png)



#### 14.5.2 私有IP地址

![](D:\项目\markdown\计算机网络\私有IP地址.png)



### 14.6 IP子网划分与子网掩码

#### 14.6.1 子网划分

![](D:\项目\markdown\计算机网络\子网划分.png)

如何确定子网划分？

​	子网掩码

**形如IP地址**：![](D:\项目\markdown\计算机网络\子网掩码.png)

​	32位，点分十进制形式

**取值**

​	NetID,SubID位全取1

​	HostID位全取0

例如：

​	A类的默认子网掩码为：255.0.0.0

​	B类的默认子网掩码为：255.255.0.0

​	C类的默认子网掩码为：255.255.255.0

​	借用3比特划分子网的B网的子网掩码为：255.255.224.0



子网地址+子网掩码---->准确确定子网大小



![](D:\项目\markdown\计算机网络\子网划分案例.png)



#### 14.6.2 子网掩码应用

路由器如何确定应该将IP分组划分到哪个子网？

​	将IP分组的目的IP地址与子网掩码按位与运算，提取子网地址



​	![](D:\项目\markdown\计算机网络\子网掩码应用案例.png)



![](D:\项目\markdown\计算机网络\一个C类网络划分子网举例.png)

第四列中，红色地址都为子网地址，绿色地址都为广播地址，不可分配地址

子网划分会造成一定的IP地址浪费，但会提升性能



### 14.7 CIDR

无类域间路由（CIDR：Classless InterDomain Routing)

​	消除传统的A类、B类和C类地址界限

​		NetID+SubID->Network Prefix(Prefix)可以任意长度

融合子网地址与子网掩码，方便子网划分

​	无类地址格式：a.b.c.d/x，其中x为前缀长度



例如

​	![](D:\项目\markdown\计算机网络\CIDR.png)

​	子网201.2.3.64，255.255.255.192->201.2.3.64/26



提高IPv4地址空间分配效率

提高路由效率			

​	将多个子网聚合为一个较大的子网

​	构造超网

​	路由聚合



#### 14.7.1 路由聚合

![](D:\项目\markdown\计算机网络\路由聚合.png)

避免黑洞现象

![](D:\项目\markdown\计算机网络\避免黑洞现象.png)



### 14.8 DHCP协议

一个主机如何获得IP地址？

硬编码

​	静态配置

动态主机配置协议（Dynamic Host Configuration Protocol)

​	从服务器动态获取：

​		IP地址

​		子网掩码

​		默认网关地址

​		DNS服务器名称与IP地址

​	即插即用

​	允许地址重用

​	支持移动用户加入网络



**步骤：**

主机广播“DHCP discover”（发现报文）

DHCP服务器利用“DHCP offer"（提供报文） 进行响应

主机请求IP地址：”DHCP request"(请求报文)

DHCP服务器分配地址：“DHCP ack"（确认报文）

![](D:\项目\markdown\计算机网络\DHCP工作过程示例.png)





DHCP协议在应用层实现

​	请求报文封装到UDP数据报中

​	IP广播

​	链路层广播（e.g. 以太网广播）

DHCP服务器构造ACK报文

​	包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址



### 14.9 NAT

网络地址转换

![](D:\项目\markdown\计算机网络\网络地址转换.png)

#### 14.9.1 动机：

只需/能从ISP申请一个IP地址

​	IPv4地址耗尽

本地网络设备IP地址的变更，无需通告外界网络

变更ISP时，无需修改内部网络设备IP地址

内部网络设备对外界网络不可见，即不可直接寻址



#### 14.9.2 实现：

替换：

​	利用（NAT IP地址，新端口号）替换每个外出IP数据报的（源IP地址，源端口号）

记录：

​	将每对（NAT IP地址，新端口号）与（源IP地址，源端口号）的替换信息存储到NAT转换表中

替换：

​	根据NAT转换表，利用（源IP地址，源端口号）替换每个进入内网IP数据报的（目的IP地址，目的端口号），即（NAT IP地址，新端口号）	



![](D:\项目\markdown\计算机网络\网络地址转换过程.png)

16-bit端口号字段：

​	可以同时支持60，000多并行连接



#### 14.9.3 问题：

NAT主要争议：

​	路由器应该只处理第三层功能

​	违背端到端通信原则

​		应用开发者必须考虑到NAT的存在，e.g.,P2P应用

​	地址短缺问题应该由IPv6来解决



![](D:\项目\markdown\计算机网络\NAT穿透问题.png)

![](D:\项目\markdown\计算机网络\NAT穿透问题2.png)

![](D:\项目\markdown\计算机网络\NAT穿透问题3.png)



### 14.10 ICMP协议

互联网控制报文协议（Internet Control Message Protocol)

支持主机或路由器

​	差错报告

​	网络探询



#### 14.10.1 两类ICMP报文：

##### 差错报告报文（5种）

​	目的不可达

​	源抑制

​	超时/超期

​	参数问题

​	重定向

##### 网络探寻报文（2组）

​	回声请求与应答报文

​	时间戳请求与应答报文



![](D:\项目\markdown\计算机网络\ICMP报文.png)





#### 14.10.2 例外情况

不是所有情况都需要发ICMP报文



**几种不发送ICMP差错报文的特殊情况：**

​	对ICMP差错报文不再发送ICMP差错报文

​	除第一个IP数据报分片外，对后续所有分片均不发送

​	对所有多播IP数据报均不发送

​	对具有特殊地址（如127.0.0.0或0.0.0.0）的IP数据报不发送

**几种ICMP报文已不再使用**

​	信息请求与应答报文

​	子网掩码请求和应答报文

​	路由器询问和通告报文



#### 14.10.3 ICMP报文格式

![](D:\项目\markdown\计算机网络\ICMP报文格式.png)



#### 14.10.4 ICMP差错报文格式

![](D:\项目\markdown\计算机网络\ICMP差错报文格式.png)



#### 14.10.5 应用举例

Traceroute



源主机向目的主机发送一系列UDP数据报

​	第1组IP数据报TTL = 1

​	第2组IP数据报TTL = 2

​	目的端口号不可能使用的端口号

当第N组数据报（TTL = N）到达第n个路由器时

​	路由器丢弃数据报

​	向源主机发送ICMP报文（type = 11, code = 0)

​	ICMP报文携带路由器名称和IP地址信息

当ICMP报文返回到源主机时，记录RTT

​	

停止准则：

​	UDP数据报最终到达目的主机

​	目的主机返回“目的端口不可达”ICMP报文（type = 3, code = 3)

​	源主机停止



### 14.11 IPV6

##### 动机：

最初动机：32位IPv4地址空间已分配殆尽

其他动机：改进首部格式

​	快速处理/转发数据报

​	支持QoS



##### 数据报格式

​	固定长度的40字节基本首部

​	不允许分片

![](D:\项目\markdown\计算机网络\IPv6数据报格式.png)

![](D:\项目\markdown\计算机网络\IPv6数据报格式2.png)

优先级：标识数据报的优先级

流标签：标识同一“流”中的数据报

下一个首部：标识下一个选项首部或上层协议首部（如TCP首部）

跳步限制：在网络中能过经过路由器数



##### 和IPv4对比

![](D:\项目\markdown\计算机网络\IPv6与v4.png)



##### IPv6地址表示形式

###### 一般形式：

​	1080：0：FF：0：8：800：200C：417A

###### 压缩形式：

​	FF01:0:0:0:0:0:0:43 ->FF01::43,不能出现两次连续的冒号

###### IPv4嵌入形式：

​	前80比特为0，接下来16比特为1，剩余32为IPv4

​	0：0：0：0：0：FFFF：13.1.68.3 或 ：：FFFF：13.1.68.3

**地址前缀：**

​	2002：43c：476b：：/48 （注：IPv6不再使用掩码！）

###### URLs：

​	http://[3FFE::1:8000:200C:417A]:8000



##### IPv6基本地址类型

![](D:\项目\markdown\计算机网络\IPv6基本地址类型.png)



##### IPv4向IPv6过渡

不可能在某个时刻所有路由器同时被更新为IPv6

​	不会有“标识性的日期”

​	IPv4和IPv6路由器共存的网络如何运行？

隧道：IPv6数据报作为IPv4数据报的载荷进行封装，穿越IPv4网络

![](D:\项目\markdown\计算机网络\隧道.png)





### 例题

![](D:\项目\markdown\计算机网络\网络层例题.png)

![](D:\项目\markdown\计算机网络\网络层例题2.png)

解：

（1）把IP地址空间202.118.1.0/24划分为2个等长的子网。划分结果：

子网1：子网地址为202.118.1.0，子网掩码为255.255.255.128（或子网1：202.118.1.0/25）

子网2：子网地址为202.118.1.128，子网掩码为255.255.255.128（或子网2：202.118.1.128/25）

（子网地址和广播地址不可分配）

地址分配方案：局域网1分配地址1，局域网2分配地址2



（2）以题1分配为前提

| 目的网络IP地址 |    子网掩码     | 下一跳IP地址 | 接口 |
| :------------: | :-------------: | :----------: | :--: |
|  202.118.1.0   | 255.255.255.128 |     直连     |  E1  |
| 202.118.1.128  | 255.255.255.128 |     直连     |  E2  |
|  202.118.3.2   | 255.255.255.255 | 202.118.2.2  |  L0  |
|    0.0.0.0     |     0.0.0.0     | 202.118.2.2  |  L0  |



（3）使用路由聚合技术

| 目的网络IP地址 |   子网掩码    | 下一跳IP地址 | 接口 |
| :------------: | :-----------: | :----------: | :--: |
|  202.118.1.0   | 255.255.255.0 | 202.118.2.1  |  L0  |



### 14.12 路由算法

确定去往目的网络的最佳路径

![](D:\项目\markdown\计算机网络\网络抽象：图.png)

![](D:\项目\markdown\计算机网络\图抽象：费用.png)

#### 14.12.1 路由算法分类

##### 静态路由

手工配置，路由更新慢，优先级高

##### **动态路由**

路由更新快

​	定期更新；及时响应链路费用或网络拓扑变化



##### **全局信息**

所有路由器掌握完整的网络拓扑和链路费用信息

​	E.g. 链路状态路由算法

##### **分散信息**

路由器只掌握物理相连的邻居以及链路费用

邻居间信息交换、运算的迭代过程

​	E.g. 距离向量路由算法



#### 14.12.2 链路状态路由算法

Dijkstra

所有结点掌握网络拓扑和链路费用

​	通过“链路状态广播”

​	所有结点拥有相同信息

计算从一个结点（“源”）到达所有其他结点的最短路径

​	获得该结点的转发表

迭代：K次迭代后，得到到达k个目的结点的最短路径

![](D:\项目\markdown\计算机网络\迪杰斯特拉例.png)

![](D:\项目\markdown\计算机网络\迪杰斯特拉生成.png)

![](D:\项目\markdown\计算机网络\迪杰斯特拉讨论.png)



#### 14.12.3 距离向量路由算法

Bellman-Ford（动态规划）



##### 结点x：

​	已知到达每个邻居的费用：c(x,v)

​	维护其所有邻居的距离向量：Dv=【Dv（y）：y∈N】



##### 核心思想：

​	每个结点不定时地将其自身的DV估计发送给其邻居

​	当x接收到邻居的新的DV估计时，即依据B-F更新其自身的距离向量估计：

​	Dx（y)将最终收敛于实际的最小费用dx(y)



##### 异步迭代：

引发每次局部迭代的因素

​	局部链路费用改变

​	来自邻居的DV更新



##### 分布式：

每个结点只当DV变化时才通告给邻居

​	邻居在必要时（其DV更新后发生改变）再通知他们的邻居



##### 每个结点：

 →等待（本地局部链路费用变化或者收到邻居的DV更新）

|				   	            |

|						           |

|							       ↓

|                     重新计算DV估计

|								   |

|							       |

|						   	    ↓

|  如果DV中到达任一目的距离发生改变，通告所有邻居

|								    |

↑————————←



![](D:\项目\markdown\计算机网络\距离路由算法举例.png)

##### 链路费用变化：

结点检测本地链路费用变化

更新路由信息，重新计算距离向量

如果DV改变，通告所有邻居



t0:y检测到链路费用改变，更新DV，通告其邻居

t1:z收到y的DV更新，更新其距离向量表，计算到达x的最新最小费用，更新其DV，并发送给其所有邻居

t2：y收到z的DV更新，更新其距离向量表，重新计算y的DV,未发生改变，不再向z发送DV

好消息（链路费用变低）——好消息传播快

坏消息（链路费用变高）——坏消息传播慢

![](D:\项目\markdown\计算机网络\无穷计数.png)

![](D:\项目\markdown\计算机网络\毒性逆转.png)

![](D:\项目\markdown\计算机网络\解决无穷计数.png)



### 14.13 层次路由

将任意规模网络抽象为一个图计算路由——过于理想化

​	标识所有路由器

​	扁平网络

——在实际网络（尤其是大规模网络）中，不可行！



网络规模：考虑6亿目的结点的网络

​	路由表几乎无法存储！

​	路由计算过程的信息（e.g. 链路状态分组、DV）交换量巨大，会淹没链路！



管理自治：

​	每个网络的管理可能都期望自主控制其网内的路由

​	互联网 = 网络之网络



聚合路由器为一个区域：自治系统AS（autonomous systems)

同一AS内的路由器运行相同的路由协议

​	自治系统内部路由协议

​	不同自治系统内的路由器可以运行不同的AS内部路由协议



网关路由器

​	位于AS边缘

​	通过链路连接其他AS的网关路由器



![](D:\项目\markdown\计算机网络\互连AS.png)

#### 14.13.1 自治系统间路由任务

![](D:\项目\markdown\计算机网络\自治系统间路由任务.png)



例：

![](D:\项目\markdown\计算机网络\路由器1d的转发表设置.png)

![](D:\项目\markdown\计算机网络\在多AS间选择.png)

![](D:\项目\markdown\计算机网络\热土豆路由.png)



### 14.14 Internet路由

Internet采用层次路由

AS内部路由协议也成为内部网络协议IGP（interior gateway protocols）

最常见的AS内部路由协议：

​	路由信息协议:RIP（Routing Information Protocol）

​	开放最短路径优先：OSPF（Open Shortest Path First)

​	内部网关路由协议：IGRP（Interior Gateway Routing Protocol）

​		Cisco 私有协议



#### 14.14.1 RIP

距离向量路由算法

​	距离度量：跳步数（max = 15 hops），每条链路1个跳步

​	每隔30秒，邻居之间交换一次DV，成为通告(advertisement)

​	每次通告：最多25个目的子网（IP地址形式）

![](D:\项目\markdown\计算机网络\RIP.png)

![](D:\项目\markdown\计算机网络\RIP举例.png)



##### 链路失效、恢复

如果180秒没有收到通告-->邻居/链路失效

​	经过该邻居的路由不可用

​		重新计算路由

​	向邻居发送新的通告

​	邻居再依次向外发送通告（如果转发表改变）

​	链路失效信息能否快速传播到全网？

​		可能发生无穷计数问题

​	毒性逆转技术用于预防ping-pong环路（另外：无穷大距离= 16hops）



##### 路由表的处理

路由表是利用一个称作route-d（deamon）的应用层进程进行管理

​	应用进程实现

通告报文周期性地通过UDP数据报发送

![](D:\项目\markdown\计算机网络\RIP路由表处理.png)



#### 14.14.2 OSPF

"开放"：公众可用

采用链路状态路由算法

​	LS分组扩散（通告）

​	每个路由器构造完整的网络拓扑图

​	利用Dijkstra算法计算路由

OSPF通告中每个入口对应一个邻居

OSPF通告在整个AS范围泛洪

​	OSPF报文直接封装在IP数据报中

与OSPF极其相似的一个路由协议：IS-IS路由协议



##### 优点（RIP不具备）	

安全：所有OSPF报文可以被认证（预防恶意入侵）

允许使用多条相同费用的路径（RIP只能选一条）

对于每条链路，可以针对不同的TOS设置多个不同费用度量

​	（e.g. 卫星链路可以针对best effort TOS设置“低”费用，针对实时TOS设置“高”费用

集成单播路由与多播路由

​	多播OSPF协议（MOSPF）与OSPF利用相同的网络拓扑协议

​	OSPF支持对大规模AS分层



##### 分层的OSPF	

![](D:\项目\markdown\计算机网络\分层的OSPF.png)

区边界路由器：汇总到达所在区网络的距离，通告给其他区边界路由器

主干路由器：在主干区内运行OSPF路由算法

AS边界路由器：连接其他AS



#### 14.14.3 BGP

边界网关协议BGP（Border Gateway Protocol)事实上的标准域间路由协议

​	将Internet:将Internet“粘合“为一个整体的关键

BGP为每个AS提供了一种手段：

​	eBGP：从邻居AS获取子网可达性信息。

​	iBGP：向所有AS内部路由器传播子网可达性信息

​	基于可达性信息与策略，确定到达其他网络的”好“路径

容许子网向Internet其余部分通告它的存在：”我在这儿！“



##### 基础

BGP会话：两个BGP路由器（”Peers")交换BGP报文：

​	通告去往不同目的前缀的路径（“路径向量（path vector）”协议）

​	报文交换基于半永久的TCP连接

BGP报文：

​	OPEN：与peer建立TCP连接，并认证发送方

​	UPDATE：通告新路径（或撤销原路径）

​	KEEPALIVE:在无UPDATE时，保活连接；也用于对OPEN请求的确认

​	NOTIFICATION:报告先前报文的差错；也被用于关闭连接



当AS3通告一个前缀给AS1时：

​	AS3承诺可以将数据包转发给该子网

​	AS3在通告中会聚合网络前缀

![](D:\项目\markdown\计算机网络\分发路径信息.png)



##### 路径属性与BGP路由(route)

通告的前缀信息包括BGP属性

​	前缀+属性= “路由”

两个重要属性：

​	AS-PATH（AS路径）：包含前缀通告所经过的AS序列：e.g.,AS 67, AS 17

​	NEXT-HOP(下一跳)：开始一个AS-PATH的路由器接口，指向下一跳AS

​		可能从当前AS到下一跳AS存在多条链路

![](D:\项目\markdown\计算机网络\BGP路由.png)



##### BGP路由选择

网关路由器收到路由通告后，利用其输入策略决策接受/拒绝该路由

​	e.g.,从不将流量路由到AS x

​	基于策略路由

路由器可能获知到达某目的AS的多条路由，基于以下准则选择：

​	1.本地偏好值属性：策略决策

​	2.最短AS-PATH

​	3.最近NEXT-HOP路由器：热土豆路由

​	4.附加准则



![](D:\项目\markdown\计算机网络\路由选择策略.png)

![](D:\项目\markdown\计算机网络\路由选择策略2.png)



#### 14.14.5 为什么采用不同的AS内与AS间路由协议

##### 策略：

inter-AS:期望能够管理控制流量如何被路由，谁路由经过其网络等

intra-AS:单一管理，无需策略决策

##### 规模：

层次路由节省路由表大小，减少路由更新流量

适应大规模互联网

##### 性能：

intra-AS:侧重性能

inter-AS：策略主导



## 15. 数据链路层

主机和路由器：结点

连接相邻结点的通信信道：链路

​	有线链路

​	无线链路

​	局域网

链路层（第二层）数据分组：帧，封装网络层数据报



数据链路层负责通过一条链路从一个节点向另一个物理链路直接相连的相邻节点传送数据报



### 15.1 链路层服务

#### 组帧(framing)：

​	封装数据报构成数据帧，加首部和尾部

​	帧同步

#### 链路接入(link access)

​	如果是共享介质，需要解决信道接入

​	帧首部中的”MAC“地址，用于标识帧的源和目的

​		不同于IP地址！

#### 相邻结点间可靠交付

​	在低误码率的有线链路上很少采用（如光纤，某些双绞线等）

​	无线链路：误码率高，需要可靠交付

#### 流量控制：

​	协调相邻的发送结点和接收

#### 差错检测：

​	信号衰减和噪声会引起差错

​	接收端检测到差错：

​		通知发送端重传或者直接丢弃帧

#### 差错纠正：

​	接收端直接纠正比特差错

#### 全双工和半双工通信控制

​	全双工：链路两端结点同时双向传输

​	半双工：链路两端结点交替双向传输

![](D:\项目\markdown\计算机网络\链路层的具体实现.png)

![](D:\项目\markdown\计算机网络\网卡间通信.png)



### 15.2 差错编码

#### 差错编码基本原理：

​	D->DR,其中R为差错检测与纠正比特（冗余比特）

![](D:\项目\markdown\计算机网络\差错编码.png)



#### 差错编码的检错能力：

汉明距离：两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数

1011101 与 1001001 之间的汉明距离是 2。

2143896 与 2233796 之间的汉明距离是 3。

"toned" 与 "roses" 之间的汉明距离是 3。

![](D:\项目\markdown\计算机网络\差错编码的检错能力.png)



#### 奇偶校验码

![](D:\项目\markdown\计算机网络\奇偶校验码.png)

#### internet校验和

![](D:\项目\markdown\计算机网络\Internet校验和.png)

#### 循环冗余校验码

![](D:\项目\markdown\计算机网络\循环冗余检验码（CRC）.png)

![](D:\项目\markdown\计算机网络\CRC举例.png)

结果为101110000 + 011 = 101110011

接收方，接着使用1001除上述结果，如果余数为0则无差错，不为0则有差错



### 15.3 多路访问控制（MAC）协议

mutiple access control protocol

两类”链路“：

**点对点链路**

​	拨号接入的PPP

​	以太网交换机与主机间的点对点链路

**广播链路（共享介质）**

​	早期的总线以太网

​	HFC的上行链路

​	802.11 无线局域网

![](D:\项目\markdown\计算机网络\广播链路.png)



单一共享广播信道

两个或者两个以上结点同时传输：干扰

​	冲突

​		结点同时接收到两个或者多个信号->接受失败！



MAC协议：

采用分布式算法决定结点如何共享信道，即决策结点何时可以传输数据

必须基于信道本身，通信信道共享协调信息！



#### 15.3.1 理想MAC协议

给定：速率为Rbps的广播信道

期望：

​	1.当只有一个结点希望传输数据时，它可以以速率R发送

​	2.当有M个结点期望发送数据时，每个结点平均发送数据的平均速率是R/M

​	3.完全分散控制：

​		无需特定结点协调

​		无需时钟、时隙同步

​	4.简单



#### 15.3.2 MAC协议分类

##### 信道划分MAC协议

网络负载重时，共享信道效率高，且公平

网络负载轻时，共享信道效率低

多路复用技术

TDMA\FDMA\CDMA\WDMA等

![](D:\项目\markdown\计算机网络\信道划分TDMA.png)

![](D:\项目\markdown\计算机网络\信道划分FDMA.png)



##### 随机访问协议

网络负载轻时，共享信道效率高，单个结点可以利用信道的全部带宽

网络负载重时，产生冲突开销



信道不划分、允许冲突

采用冲突”恢复“机制



当结点要发送分组时：

​	利用信道全部数据速率R发送分组

​	没有事先的结点间协调

两个或多个结点同时传输：->"冲突"

随机访问MAC协议需要定义：

​	如何检测冲突

​	如何从冲突中恢复(e.g.，通过延迟重传)

典型的随机访问MAC协议：

​	时隙ALOHA

​	ALOHA

​	CSMA、CSMA/CD、CSMA/CA



###### 时隙ALOHA

**假定：**

​	所有帧大小相同

​	时间被划分为等长的时隙（每个时隙可以传输1个帧）

​	结点只能在时隙开始时刻发送帧

​	结点间时钟同步

​	如果2个或2个以上结点在同一时隙发送帧，结点即检测到冲突

**运行：**

​	当结点有新的帧时，在下一个时隙发送

​		如果无冲突：该结点可以在下一个时隙继续发送新的帧

​		如果冲突：该结点在下一个时隙以概率p重传该帧，直至成功

![](D:\项目\markdown\计算机网络\时隙ALOHA案例.png)

![](D:\项目\markdown\计算机网络\时隙ALOHA效率.png)



###### ALOHA协议

非时隙ALOHA：更加简单，无需同步

当有新的帧生成时

​	立即发送

冲突可能性增大：

​	在t0时刻发送帧，会在【t0-1,t0+1】期间其他结点发送的帧冲突

![](D:\项目\markdown\计算机网络\ALOHA协议.png)

![](D:\项目\markdown\计算机网络\ALOHA协议效率.png)

###### CSMA协议

载波监听多路访问协议CSMA

carrier sense mutiple access

发送帧之前，监听信道（载波）：

​	信道空闲：发送完整帧

​	信道忙：推迟发送

​		1-坚持CSMA：当发现信道忙，不能马上发送数据帧，以概率为1监听信道，一旦发现空闲，立刻发送数据帧

​		非坚持CSMA：当发现信道忙，随即等待一段时间后，监听信道

​		P-坚持CSMA：当发现信道忙，以概率为P监听信道，I-P等待一段时间后，监听信道

冲突可能仍然发生：

​	信号传播延迟

继续发送冲突帧：浪费信道资源

![](D:\项目\markdown\计算机网络\CSMA示例.png)



###### CSMA/CD协议

CSMA with Collision Detection

短时间内可以检测到冲突

冲突后传输中止，减少信道浪费

冲突检测：

​	有线局域网易于实现：测量信号强度，比较发射信号与接收信号

​	无线局域网很难实现；接收信号强度淹没在本地发射信号强度下

![](D:\项目\markdown\计算机网络\CSMACD检测冲突.png)

**”边发边听，不发不听“**

![](D:\项目\markdown\计算机网络\CSMACD示例.png)

![](D:\项目\markdown\计算机网络\CSMACD例题.png)

![](D:\项目\markdown\计算机网络\CSMACD效率.png)



##### 轮转MAC协议

结点轮流使用使用信道



###### 轮询（polling）

主结点轮流”邀请“从属结点发送数据![](D:\项目\markdown\计算机网络\轮询.png)

典型应用：

​	dumb：从属设备

问题：

​	轮询开销

​	等待延迟

​	单点故障



###### 令牌传递（token passing）

控制令牌依次从一个结点传递到下一个结点

令牌：特殊帧![](D:\项目\markdown\计算机网络\令牌传递.png)

问题：

​	令牌开销

​	等待延迟

​	单点故障



#### 15.3.3 MAC协议总结

![](D:\项目\markdown\计算机网络\MAC协议总结.png)



## 16. 局域网

### 16.1 MAC地址

（或称LAN地址，物理地址，以太网地址）：

​	作用：用于局域网内标识一个帧从哪个接口出发，到达哪个物理相连的其他接口

​	48位MAC地址（用于大部分LANs），固化在网卡的ROM中，有时也可以软件设置

​	e.g.:1A-2F-BB-76-09-AD



局域网的每块网卡都有一块MAC地址

![](D:\项目\markdown\计算机网络\MAC地址.png)



MAC地址由IEEE统一管理与分配

网卡生产厂商购买MAC地址空间（前24比特）

类比：

​	MAC地址：身份证号

​	IP地址：邮政地址

MAC地址是“平面”地址：->可“携带”

​	可以从一个LAN移到另一个LAN

IP地址依赖于结点连接到哪个子网



### 16.2 ARP

地址解析协议

ARP表：LAN中的每个IP结点（主机、路由器）维护一个表

​	存储某些LAN结点的IP/MAC地址映射关系：

​		<IP地址；MAC地址；TTL>

​	TTL(Time to Live):

​		经过这个时间以后该映射关系会被遗弃（典型值为20min)



#### 16.2.1 同一局域网内

A想要给同一局域网内的B发送数据报

​	B的MAC地址不在A的ARP表中

A广播ARP查询分组，其中包含B的IP地址

​	目的MAC地址 = FF-FF-FF-FF-FF-FF

​	LAN中所有结点都会接收ARP查询

B接收ARP查询分组，IP地址匹配成功，向A应答B的MAC地址

​	利用单播帧向A发送应答

A在其ARP表中，缓存B的IP-MAC地址对，直至超时

​	超时后，再次刷新

ARP是“即插即用”协议：

​	结点自主创建ARP表，无需干预



#### 16.2.2 从一个LAN路由至另一个LAN

通信过程：A通过路由器R向B发送数据报

​	关注寻址：IP地址（数据报中）和MAC地址（帧中）

​	假设A知道B的IP地址

​	假设A知道第一跳路由器R（左）接口IP地址

​	假设A知道第一跳路由器R（左）接口MAC地址（通过ARP）

​	路由器R通过ARP知道B的MAC

![](D:\项目\markdown\计算机网络\ARP从一个局域网到另一个局域网.png)

步骤：

​	A构造IP数据报，其中源IP地址是A的IP地址，目的IP地址是B的IP地址

​	A构造链路层帧，其中源MAC地址是A的MAC地址，目的MAC地址是R（左）接口的MAC，封装A到B的IP数据报。

​	帧从A发送至R，R接收帧，提取IP数据报，传递给上层IP协议

​	R转发IP数据报（源和目的IP地址不变）

​	R创建链路层帧，其中源MAC地址是R（右）接口的MAC地址，目的MAC地址是B的MAC地址，封装A到B的IP数据报



### 16.3 以太网Ethernet	

​	统治地位的有线LAN技术：

造价低廉(以太网网卡不足百元)

应用最广泛的LAN技术

比令牌局域网和ATM等，简单、便宜

满足网络速率需求：10Mbps~10Gbps



#### 16.3.1 物理拓扑

##### 总线bus:

​	所有结点在同意冲突域（冲突域，任何两个网络结点同时发送数据就会产生冲突的范围）

![](D:\项目\markdown\计算机网络\总线以太网.png)

##### 星型star：

​	目前主流网络拓扑	

​	中心交换机

​	每个结点一个单独冲突域（结点间彼此不冲突）

![](D:\项目\markdown\计算机网络\星形以太网.png)



#### 16.3.2 不可靠、无连接服务

无连接：发送帧的网卡与接收帧的网卡间没有”握手“过程

不可靠：接受网卡不祥发送网卡进行确认

​	差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议（e.g. TCP），否则发生数据丢失

以太网的MAC协议：采用二进制指数退避算法的CSMA/CD



#### 16.3.3 以太网CSMA/CD算法

1.以太网卡从网络层接收数据报，创建数据帧

2.监听信道：

​	如果NIC监听到信道空闲，则开始发送帧；

​	如果NIC监听到信道忙，则一直等待到信道空闲，然后发送帧

3.以太网卡发送完整个帧，而没有检测到其他结点的数据发送，则以太网卡确认帧发送成功！

4.如果以太网卡检测到其他结点传输数据，则中止发送，并发送堵塞信号（jam signal）

5.中止发送后，以太网卡进入二进制指数退避：

​	第m次连续冲突后：取n = Min(m,10)

​	以太网卡从{0，1，2，...,2的n次方-1}中随机选择一个数K

​	以太网卡等待K×512比特的传输延迟时间，再返回第2步

​	连续冲突次数越多，平均等待时间越长

​	如果连续16次冲突，报告错误



#### 16.3.4 以太网帧结构

发送端网卡将IP数据报（或其他网络层协议分组）封装到以太网帧中：

![](D:\项目\markdown\计算机网络\以太网帧结构.png)

**前导码（Preamble)(8B):**

7个字节的10101010，第8字节为10101011

用于发送端与接收端的时钟同步



**目的MAC地址、源MAC地址（各6B）：**

​	如果网卡的MAC地址与收到的帧的目的MAC地址匹配，或者帧的目的MAC地址为广播地址（FF-FF-FF-FF-FF-FF)则网卡接收该帧，并将其封装的网络层分组交给相应的网络层协议



**类型（TYPE）（2B）：**

​	指示帧中封装的是哪种高层协议的分组（如：IP数据报、Novell IPX数据报、AppleTalk数据报等）



**数据（Data)(46-1500B):**

​	指上层协议载荷

![](D:\项目\markdown\计算机网络\以太网帧最短长度.png)

#### CRC(4B)：

​	循环冗余校验码



#### 16.3.5 以太网标准

![](D:\项目\markdown\计算机网络\以太网标准.png)



### 16.4 以太网交换机

链路层设备

​	存储-转发以外网帧

​	检验到达帧的目的MAC地址，选择性(selectively)向一个或多个输出链路转发帧

​	利用CSMA/CD访问链路，发送帧

透明

​	主机感知不到交换机的存在

即插即用

自学习

交换：A-A' 与 B-B‘的传输可以同时进行，没有冲突

![](D:\项目\markdown\计算机网络\交换机.png)

#### 16.4.1 多端口间同时传输

主机利用独享链路直接连接交换机

交换机缓存帧

交换机在每段链路上利用CSMA/CD收发帧，但无冲突，且可以全双工

​	每段链路一个独立的冲突域



#### 16.4.2 交换表

Q：交换机怎么知道A’可以通过接口4到达，而B‘可以通过接口5到达？

A：每个交换机有一个交换表，每个入口：

​	主机MAC地址，到达主机的接口，时间戳

​	看起来很像路由表！



Q：交换表入口信息如何创建和维护？

A：自学习



#### 16.4.3 自学习

交换机通过自学习，获知到主机的接口信息

​	当收到帧时，交换机”学习：到发送帧的主机（通过帧的源MAC地址），位于收到该帧的接口所连接的LAN网段

​	将发送主机MAC地址/接口信息记录的到交换表中



当A发给A'数据帧时，通过接口1发送到交换机，交换机就记住A的MAC地址和接口1

![](D:\项目\markdown\计算机网络\交换表1.png)



#### 16.4.4 帧过滤/转发

当交换机收到帧：

​	1.记录帧的源MAC地址与输入链路接口

​	2.利用目的MAC地址检索交换表

​	3.if在交换表中检索到与目的MAC地址匹配的入口(entry){

​			if(目的主机位于收到帧的网段)

​					丢弃帧

​		else

​				将帧转发到该入口指向的接口

​	}else

​		泛洪 向除收到该帧的接口之外的所有接口转发

![](D:\项目\markdown\计算机网络\自学习与转发过程举例.png)



#### 16.4.5 交换机互联

![](D:\项目\markdown\计算机网络\交换机互联.png)



#### 16.4.6 组织机构网络

![](D:\项目\markdown\计算机网络\组织机构网络.png)



#### 16.4.7 网络设备对比

![](D:\项目\markdown\计算机网络\交换机VS路由器.png)

![](D:\项目\markdown\计算机网络\网络设备对比.png)



### 16.5 VLAN

Virtual Local Area Network

支持VLAN划分的交换机，可以在一个物理LAN架构上配置、定义多个VLAN



基于端口的VLAN：分组交换机端口（通过交换机管理软件）

![](D:\项目\markdown\计算机网络\vlan1.png)

![](D:\项目\markdown\计算机网络\vlan2.png)

**流量隔离：**

​	去往/来自端口1-8的帧只到达端口1-8

​		也可以基于MAC地址定义VLAN，而不是交换端口

**动态成员：**

​	端口可以动态分配给不同VLAN

**在VLAN间转发：通过路由（就像在独立的交换机之间）**

​	实践中，厂家会将交换机与路由器集成在一起

![](D:\项目\markdown\计算机网络\在vlan间转发.png)



#### 16.5.1 跨越多交换机的VLAN

![](D:\项目\markdown\计算机网络\跨越多交换机的VLAN.png)

##### 多线缆连接

​	每个线缆连接一个VLAN

##### 中继端口（trunk port）

​	在跨越多个物理交换机定义的VLAN承载帧

​	为多VLAN转发802.1帧容易产生歧义（必须携带VLAN ID信息）

​	802.1q协议为经过中继接口转发的帧增加/去除额外的首部域

##### 802.1Q VLAN帧格式

![](D:\项目\markdown\计算机网络\802.1Q帧格式.png)

### 16.6 PPP协议

点对点链路数据控制

一个发送端，一个接收端，一条链路：比广播链路容易

​	无需介质访问控制

​	无需明确的MAC寻址

​	e.g.,拨号链路，ISDN链路

常见的点对点数据链路控制协议：

​	HDLC：High Level Data Link Control

​	PPP: Point-to-Point Protocol



#### 16.6.1 设计需求

组帧：将网络层数据报封装到数据链路层帧中

​	可以同时承载任何网络层协议分组（不仅IP数据报）

​	可以向上层实现分用（多路分解）

比特透明传输：数据域必须支持承载任何比特模式

差错检测：无纠正

连接活性检测：检测、并向网络层通知链路失效

网络层地址协商：端结点可以学习/配置彼此网络地址



#### 16.6.2 无需支持的功能

无需差错纠正/恢复

无需流量控制

不存在乱序交互

无需支持多点链路

​     **差错恢复、流量控制等由高层协议处理**



#### 16.6.3 PPP数据帧

标志：定界符（知道一个帧的起止）

地址：无效（全1）

控制：无效

协议：上层协议（1个字节或2个字节）

信息：上层协议分组数据（可变）

校验：CRC校验，用于差错检测（2个字节或4个字节）

![](D:\项目\markdown\计算机网络\PPP数据帧.png)

协商之后最多可节约5个字节（地址+控制+协议的1+校验的2）



#### 16.6.4 字节填充

数据透明传输需求：数据域必须允许包含标识模式<01111110>

Q:如何判断该作为数据接收，还是作为标志处理？



发送端：

​	在数据中的<01111110>和<01111101>添加额外的字节<01111101>

接收端：

​	单个字节<01111101>表示一个填充字节；

​	连续两个字节<01111101>；丢弃第1个，第2个作为数据接收

​	单个字节<01111110>：标志字节

![](D:\项目\markdown\计算机网络\字节填充.png)

#### 16.6.5 PPP协议状态

在交换网络层数据之前，PPP数据链路两端必须

配置PPP链路：

​	最大帧长

​	身份认证

学习/配置网络层信息

​	对于IP协议：通过交换IPCP协议报文，完成IP地址等相关信息配置）

​	![](D:\项目\markdown\计算机网络\PPP协议状态.png)



### 16.7 802.11 无线局域网

#### 802.11b

2.4-2.5GHz免费频段

最高速率：11Mbps

物理层采用直接序列扩频技术

​	所有主机使用相同的码片序列



#### 802.11a

5-6GHz频段

最高速率：54Mbps



#### 802.11g

2.4-2.5GHz频段

最高速率：54Mbps



#### 802.11n

多天线

2.5-2.5GHz频段

最高速率：600Mbps



均使用CSMA/CA多路访问控制协议

均有基础设施网络模式和特定网网络模式

![](D:\项目\markdown\计算机网络\802.11无线局域网.png)



#### 802.11体系结构

![](D:\项目\markdown\计算机网络\802.11体系结构.png)



#### 信道与AP关联

802.11b：2.4GHz-2.485GHz频谱划分为11个不同频率的信道

​	每个AP选择一个频率（信道）

​	存在干扰可能：相邻的AP可能选择相同的信息！

主机：必须与某个AP关联

​	扫描信道，监听包含AP名称（服务集标识符）和MAC地址的信标帧

​	选择一个AP进行关联

​	可能需要进行身份认证

​	典型情形：运行DHCP获取IP地址等信息



#### AP关联：

##### 被动扫描

各AP发送信标帧

主机H1向选择的AP发送关联请求帧

AP向主机发送关联响应帧

![](D:\项目\markdown\计算机网络\被动扫描.png)



##### 主动扫描

主机主动广播探测请求帧

AP发送探测响应帧

主机向选择的AP发送关联请求帧

AP向主机发送关联响应帧

![](D:\项目\markdown\计算机网络\主动扫描.png)



#### 多路访问控制

避免冲突：2个以上结点同时传输

802.11：CSMA-发送数据前监听信道

​	避免与正在进行传输的其他结点冲突

802.11：不能像CSMA/CD那样，边发送、边检测冲突

​	无线信道很难实现

​	无法侦听到所有可能的冲突：隐藏站、信号衰落

​	目标：避免冲突-CSMA/CA



#### CSMA/CA

![](D:\项目\markdown\计算机网络\802.11CSMACA.png)

##### CA冲突避免

基本思想：允许发送端“预约”信道，而不是随机发送数据帧，从而避免长数据帧的冲突

发送端首先利用CSMA向BS发送一个很短的RTS帧

​	RTS帧仍然可能彼此冲突

BS广播一个CTS帧作为对RTS的响应

CTS帧可以被所有结点接收

​	消除隐藏站影响

​	发送端可以发送数据帧

​	其他结点推迟发送



利用很小的预约帧彻底避免了数据帧冲突

![](D:\项目\markdown\计算机网络\RTS-CTS交换.png)



#### MAC帧

![](D:\项目\markdown\计算机网络\802.11MAC帧.png)

##### 数据帧地址

![](D:\项目\markdown\计算机网络\802.11数据帧地址.png)

![](D:\项目\markdown\计算机网络\802.11数据帧地址示例.png)





# 例题

## 1.主机子网划分

某计算机的IP地址为202.8.8.23，如果该网络的地址掩码为255.255.255.240，那么该网络最多可以划分（）个子网，每个子网最多有（）台主机

答案：16，14

解析：IP地址的23转化为二进制为：0001 0111； 255.255.255.240的 240转化为1111 0000； 二者and运算结果为0001 0000，有2^4个子网，2^4-2个主机。 



## 2.发送传送速率

数据的发送速率越高，传送的越快   不正确

发送速率 ！= 传送速率



## 3.分组交换

![](D:\项目\markdown\计算机网络\例题1.png)

解：

![](D:\项目\markdown\计算机网络\例题1解.png)

A的大小为B的2倍，分组交换下，A的时间约为B的2倍；报文交换下，A的时间约为A的1.42倍



## 4.DNS和HTTP传输

![](D:\项目\markdown\计算机网络\例题4.png)

解：

1）最短时间RTTd；（本地域名服务器可能有缓存）

​	最长时间：5RTTd;

(查本地域名服务器

​	查根服务器

​	查cn域名服务器

​	查.com.cn域名服务器

​	查kicker.com.cn域名服务器)



2）基于HTTP1.0传一次对象建立一次连接，传完一次对象断开一次连接。

​	8个图象+index.html = 9个对象  18RTTh



3)建立TCP连接，1个RTT

​	请求传输index页面，1个RTT

​	建立5个并行TCP，1个RTT

​	请求5个图像，1个RTT

​	建立3个并行TCP连接，1个RTT

​	请求3个图像，1个RTT



4）基于非流水模式HTTP1.1，

​			建立TCP连接，1个RTT

​			请求传输index页面，1个RTT

​			8个图像，8个RTT

​	

​	基于流水模式HTTP1.1

​		建立TCP连接，1个RTT

​		请求传输index页面，1个RTT

​		同时把8个图像发送，1个RTT



## 5.滑动窗口与流水线机制

![](D:\项目\markdown\计算机网络\例题5.png)



1）

GBN：

​	A共发送9个报文段，首先发送1，2，3，4，5，后来重发2，3，4，5

​	B共发送8个ACK；先是4个ACK1，然后是ACK2,ACK3,ACK4,ACK5.

​	

SR:

​	A共发送6个报文段，首先发送1，2，3，4，5，然后重发2

​	B共发送5个ACK，先发送ACK1,ACK3,ACK4,ACK5,然后是ACK2



TCP：

​	A共发送6个报文段，首先发送1，2，3，4，5，然后重发2

​	B共发送5个ACK，先发送ACK2,ACK2,ACK2,ACK2,然后发送1个ACK6



2）TCP协议；因为TCP协议有快速重传机制（即在未超时情况下就开始重传丢失的2号报文段）收到第四个ACK2时候，就开始重传（三次重复确认，第一次不是重复）



## 6.TCP拥塞窗口

![](D:\项目\markdown\计算机网络\例题6.png)

解：

​	1）当最大发送速率超过链路带宽时会发生=丢包

​	W*MSS/RTT = 8Mbps  

​	W = 100



​	2）拥塞窗口从W/2到W间变化，平均窗口尺寸 = 0.75W = 75；

​		平均吞吐量 = 平均窗口尺寸 * MSS / 传播时延 = 6Mbps



​	3）传输时延 * 最大窗口 /2 = 7.5秒

​		每个RTT窗口尺寸增加1个MSS



## 7.

![](D:\项目\markdown\计算机网络\例题7.png)

解：

（1）子网掩码，255.255.255.240（前28位全1，后4位全0）

​	 	 默认网关：192.168.1.1（离开子网所经过路由器的接口）



（2）IP分组首部的源IP地址、TTL和Checksum字段会被修改，源IP地址192.168.1.5会被替换为130.11.22.3，TTL减1，Checksum会重新计算



 （3）512-20 = 492B   488B是8的倍数

​			1500/488（向上取整） = 4个分片

| 序号 |  ID  | DF（禁止分片） | MF（更多分片） | length | offset |
| ---- | :--: | :------------: | :------------: | :----: | ------ |
| 1    | 6789 |       0        |       1        |  508   | 0      |
| 2    | 6789 |       0        |       1        |  508   | 61     |
| 3    | 6789 |       0        |       1        |  508   | 122    |
| 4    | 6789 |       0        |       0        |   36   | 183    |



## 8.

![](D:\项目\markdown\计算机网络\例题8.png)

解：

（1)DHCP服务器可为主机2~主机N到动态分配IP地址的最大范围是：

​		111.123.15.5~111.123.15.254

​		主机2发送的封装DHCP Discover报文的IP分组源和某目的分别为：

​		0.0.0.0 和255.255.255.255



（2）子网掩码（255.255.255.0）

​			默认网关（111.123.15.1）

​			域名服务器IP地址



（3）主机1能访问WWW服务器，（同一子网内）

​		但不能访问Internet，因为网关配置错了，正确是111.123.15.1



## 9.

![](D:\项目\markdown\计算机网络\例题9.png)

解：

（1）

R1路由表：

|     目的网络     | 接口 |
| :--------------: | :--: |
|  192.168.1.0/25  |  S1  |
| 192.168.1.192/26 |  E0  |
|  192.168.2.0/23  |  S0  |

（2）

R1路由表：

|     目的网络     | 接口 |
| :--------------: | :--: |
|  192.168.1.0/25  |  S1  |
| 192.168.1.128/26 |  S0  |
| 192.168.1.192/26 |  E0  |
|  192.168.2.0/23  |  S0  |

R1的距离向量

|     目的网络     | 距离 |
| :--------------: | :--: |
|  192.168.1.0/25  |  2   |
| 192.168.1.128/26 |  3   |
| 192.168.1.192/26 |  1   |
|  192.168.2.0/23  |  2   |

